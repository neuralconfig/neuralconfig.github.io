<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>neuralconfig | AI & Infrastructure Architect</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Home page specific styles */
        .home-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            padding-top: 80px; /* Add space for nav bar */
        }

        .hero-content {
            width: 100%;
            max-width: 1000px;
        }

        .brackets {
            color: var(--accent);
        }

        .terminal {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            margin: 0 auto;
            padding: 1.5rem;
            width: 100%;
            max-width: 900px;
            min-height: 450px;
            max-height: 600px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.8s ease forwards;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            font-family: 'IBM Plex Mono', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            text-align: left;
            position: relative;
        }

        /* Very subtle phosphor glow */
        .terminal .terminal-line {
            text-shadow: 0 0 1px currentColor;
        }

        /* Medium scanlines */
        .terminal::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            border-radius: 4px;
        }

        .terminal-line {
            margin: 0.2rem 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            text-align: left;
        }

        .terminal-prompt {
            color: #39ff14;
            font-weight: bold;
        }

        .terminal-command {
            color: #00ff00;
        }

        .terminal-output {
            color: #888;
            margin-left: 0;
        }

        .terminal-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: #00ff00;
            animation: blink 1s infinite;
            vertical-align: text-bottom;
            margin-left: 2px;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
            z-index: -1;
        }

        /* Scrollbar styling */
        .terminal::-webkit-scrollbar {
            width: 8px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .terminal::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* Output styling */
        .output-highlight {
            color: #39ff14;
        }

        .output-error {
            color: #ff5f56;
        }

        .output-warning {
            color: #ffbd2e;
        }

        .output-info {
            color: #00bfff;
        }

        .output-success {
            color: #27c93f;
        }

        .output-dim {
            opacity: 0.7;
        }

        .banner-line {
            color: #39ff14 !important;
        }

        /* Interactive mode styles */
        .interactive-line {
            position: relative;
        }
        
        .terminal-input {
            color: #00ff00;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .home-container {
                padding: 1rem;
                padding-top: 80px;
            }

            .terminal {
                font-size: 0.8rem;
                line-height: 1.5;
                min-height: 350px;
                max-height: 70vh;
                padding: 1rem;
            }

            .terminal-line {
                word-break: break-word;
                line-height: 1.6;
            }
            
            /* Make touch targets larger on mobile */
            .terminal {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                cursor: pointer;
            }
            
            /* Prevent zoom on focus */
            input, textarea, select {
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .terminal {
                font-size: 0.75rem;
                padding: 0.8rem;
                min-height: 300px;
            }
            
            .hero-content {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <canvas class="matrix-bg" id="matrixCanvas"></canvas>
    
    <nav class="nav-bar">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">neural<span class="brackets">[</span>config<span class="brackets">]</span></a>
            <div class="nav-links">
                <a href="skills.html" class="nav-link">about</a>
                <a href="projects.html" class="nav-link">open source</a>
                <a href="tools.html" class="nav-link">tools</a>
                <a href="mobile-apps.html" class="nav-link">mobile apps</a>
                <a href="https://github.com/neuralconfig" class="nav-link external">github</a>
            </div>
        </div>
    </nav>

    <div class="home-container">
        <div class="hero-content">
            <div class="terminal" id="terminal-output">
                <!-- Terminal content will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <footer class="footer">
        © 2025 NeuralConfig LLC | <a href="mailto:contact@neuralconfig.com" style="color: var(--accent); text-decoration: none;">contact@neuralconfig.com</a>
    </footer>

    <script src="matrix.js"></script>
    <script>
        // Terminal simulation
        const terminal = document.getElementById('terminal-output');
        let commandIndex = 0;
        let charIndex = 0;
        let isTyping = false;
        let currentLine = null;
        let typingSpeed = 40;
        let commandDelay = 3000;
        let outputDelay = 100;
        let showBanner = true;
        let interactiveMode = false;
        let autoMode = true;
        let currentInput = '';
        let commandHistory = [];
        let historyIndex = -1;
        let currentInputLine = null;
        let autoTimeouts = [];
        let interactiveTimeout = null;
        
        // Welcome banner content - different versions for mobile and desktop
        const isMobile = window.innerWidth < 768;

        const desktopBanner = [
            '████████████████████████████████████████████████████████████████████████████████',
            '',
            '                              NEURALCONFIG LLC',
            '                         AI & Network Consulting',
            '',
            '████████████████████████████████████████████████████████████████████████████████',
            '',
            '<span class="output-success">Welcome to NeuralConfig</span>',
            '',
            '[AI SYSTEMS]......................... <span class="output-success">OPERATIONAL</span>',
            '[NETWORK AUTOMATION]................. <span class="output-success">ACTIVE</span>',
            '[MOBILE DEVELOPMENT]................. <span class="output-success">IN PROGRESS</span>',
            '[CONSULTING SERVICES]................ <span class="output-success">AVAILABLE</span>',
            '[OPEN SOURCE TOOLS].................. <span class="output-success">ONLINE</span>',
            '',
            '        Contact: contact@neuralconfig.com',
            '        GitHub: github.com/neuralconfig',
            '',
            '████████████████████████████████████████████████████████████████████████████████'
        ];

        const mobileBanner = [
            '═══════════════════════════════════════',
            '',
            '         NEURALCONFIG LLC',
            '    AI & Network Consulting',
            '',
            '═══════════════════════════════════════',
            '',
            '<span class="output-success">System Status:</span>',
            '',
            '[AI SYSTEMS]......... <span class="output-success">ONLINE</span>',
            '[AUTOMATION]......... <span class="output-success">ACTIVE</span>',
            '[MOBILE APPS]........ <span class="output-success">DEV</span>',
            '[CONSULTING]......... <span class="output-success">READY</span>',
            '',
            'contact@neuralconfig.com',
            'github.com/neuralconfig',
            '',
            '═══════════════════════════════════════'
        ];

        const securityBanner = isMobile ? mobileBanner : desktopBanner;
        
        // Terminal commands and outputs
        const commands = [
            {
                prompt: 'root@neuralconfig:~#',
                command: ' whoami',
                output: [
                    '<span class="output-highlight">AI & Infrastructure Architect</span>',
                    'Specializing in AI systems, network automation, and cybersecurity',
                    '20+ years network infrastructure experience',
                    'Building intelligent systems at the intersection of AI and networking'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' ls -la projects/',
                output: [
                    'drwxr-xr-x  10 neural  staff   320 Jan 15 2025 .',
                    'drwxr-xr-x   8 neural  staff   256 Jan 15 2025 ..',
                    '-rw-r--r--   1 neural  staff  8192 Jan 15 10:23 <span class="output-success">ruckus-ztp</span> [AI-AGENT]',
                    '-rw-r--r--   1 neural  staff  4096 Jan 14 18:45 <span class="output-info">r1-api</span> [SDK]',
                    '-rw-r--r--   1 neural  staff  6144 Jan 13 14:30 <span class="output-success">osticket-agent</span> [AI-AGENT]',
                    '-rw-r--r--   1 neural  staff  3072 Jan 12 09:15 <span class="output-info">survival-rag</span> [AI-RAG]',
                    '-rw-r--r--   1 neural  staff  2048 Jan 10 16:20 <span class="output-success">sz-acl</span> [NETWORK]'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat services.yaml',
                output: [
                    '<span class="output-highlight">Core Services:</span>',
                    '  <span class="output-success">✓</span> AI System Architecture & Consulting',
                    '  <span class="output-success">✓</span> Network Automation & Zero-Touch Provisioning',
                    '  <span class="output-success">✓</span> Agentic AI Development',
                    '  <span class="output-success">✓</span> RAG Implementation & LLM Integration',
                    '  <span class="output-success">✓</span> Open Source Network Management Tools',
                    '  <span class="output-success">✓</span> iOS Mobile Application Development'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' grep -E "AI|Network|Development" skills.txt',
                output: [
                    '<span class="output-success">[✓]</span> Agentic AI System Architecture',
                    '<span class="output-success">[✓]</span> Large Language Model Integration',
                    '<span class="output-success">[✓]</span> Network Automation (Python/Ansible)',
                    '<span class="output-success">[✓]</span> RUCKUS One & SmartZone API Development',
                    '<span class="output-success">[✓]</span> Swift/iOS Development (ARKit, HealthKit)',
                    '<span class="output-success">[✓]</span> Zero-Touch Provisioning',
                    '<span class="output-success">[✓]</span> Cybersecurity (CISSP)'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' echo $MISSION',
                output: [
                    '<span class="output-highlight">"Building intelligent systems that solve real-world infrastructure challenges"</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' git log --oneline -5',
                output: [
                    '<span class="output-warning">eba9d52</span> feat: update positioning to Principal Systems Engineer',
                    '<span class="output-warning">01977cc</span> feat: add r1-api project and enhance terminal',
                    '<span class="output-warning">e9314e9</span> feat: add ruckus-ztp and enhance AI agent emphasis',
                    '<span class="output-warning">d11c795</span> feat: add RUCKUS One Python SDK',
                    '<span class="output-warning">41e41cb</span> feat: osticket autonomous AI agent'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' systemctl status automation-stack',
                output: [
                    '<span class="output-success">●</span> automation-stack.service - Network Automation Platform',
                    '   Loaded: loaded (/etc/systemd/system/automation.service; enabled)',
                    '   Active: <span class="output-success">active (running)</span> since Jan 2025',
                    '   Status: "Processing automation workflows"',
                    '   Memory: 512.0M | CPU: 2.5%'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' docker ps --format "table {{.Names}}\\t{{.Status}}"',
                output: [
                    'NAMES                STATUS',
                    'ai-agent             Up 45 days',
                    'vector-database      Up 45 days',
                    'api-gateway          Up 45 days',
                    'monitoring           Up 45 days'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' python3 -c "import this" | head -5',
                output: [
                    '<span class="output-dim">The Zen of Python, by Tim Peters</span>',
                    '',
                    '<span class="output-dim">Beautiful is better than ugly.</span>',
                    '<span class="output-dim">Explicit is better than implicit.</span>',
                    '<span class="output-dim">Simple is better than complex.</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat testimonial.txt',
                output: [
                    '<span class="output-highlight">Client Feedback:</span>',
                    '',
                    '"Exceptional technical expertise combined with practical business insight.',
                    'Delivered network automation solutions that transformed our operations."',
                    '',
                    '- Fortune 500 Technology Client'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' curl https://neuralconfig.com/tools/ | jq .available',
                output: [
                    '{',
                    '  "fastiron-navigator": "live",',
                    '  "sz-acl": "maintenance",',
                    '  "mobile-apps": "in-development"',
                    '}'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat ruckus-ztp/agent.py | head -20',
                output: [
                    '<span class="output-dim"># AI Agent for RUCKUS Zero-Touch Provisioning</span>',
                    '<span class="output-dim">from anthropic import Anthropic</span>',
                    '<span class="output-dim">import json</span>',
                    '',
                    '<span class="output-dim">def configure_device(device_info):</span>',
                    '<span class="output-dim">    """Use AI to generate optimal configuration"""</span>',
                    '<span class="output-dim">    client = Anthropic()</span>',
                    '<span class="output-dim">    response = client.messages.create(</span>',
                    '<span class="output-dim">        model="claude-3-5-sonnet-20241022",</span>',
                    '<span class="output-dim">        tools=[network_config_tool],</span>',
                    '<span class="output-dim">        messages=[{</span>',
                    '<span class="output-dim">            "role": "user",</span>',
                    '<span class="output-dim">            "content": f"Configure {device_info}"</span>',
                    '<span class="output-dim">        }]</span>',
                    '<span class="output-dim">    )</span>',
                    '',
                    '<span class="output-success">✓ Autonomous AI configuration engine</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' kubectl get pods -n production',
                output: [
                    'NAME                          READY   STATUS    RESTARTS   AGE',
                    'ai-agent-7d9f8c4b5-x9k2m      1/1     Running   0          15d',
                    'vector-db-6c8d7f9b4-p7q3n     1/1     Running   0          15d',
                    'api-gateway-5b7c8d9f2-m4r5t   1/1     Running   0          15d',
                    'rag-service-8f9d2c3b7-k6p8w   1/1     Running   0          12d',
                    '',
                    '<span class="output-success">All systems operational</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' tail -f /var/log/ai-agent/activity.log',
                output: [
                    '<span class="output-dim">2025-01-15 14:23:45</span> <span class="output-success">[INFO]</span> Processing support ticket #4521',
                    '<span class="output-dim">2025-01-15 14:23:46</span> <span class="output-success">[INFO]</span> RAG context retrieved: 15 documents',
                    '<span class="output-dim">2025-01-15 14:23:47</span> <span class="output-success">[INFO]</span> Agent decision: route to network team',
                    '<span class="output-dim">2025-01-15 14:23:48</span> <span class="output-success">[INFO]</span> Ticket categorized: L3 routing issue',
                    '<span class="output-dim">2025-01-15 14:23:49</span> <span class="output-success">[INFO]</span> Response generated and validated',
                    '',
                    '<span class="output-dim">^C</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' terraform plan -out=infrastructure.tfplan',
                output: [
                    '<span class="output-info">Terraform v1.6.0</span>',
                    '<span class="output-dim">Refreshing state... [36s elapsed]</span>',
                    '',
                    '<span class="output-success">Plan: 3 to add, 0 to change, 0 to destroy.</span>',
                    '',
                    '  + google_cloud_function.ai_agent',
                    '  + google_cloud_run.api_service',
                    '  + google_compute_instance.monitoring',
                    '',
                    '<span class="output-dim">Saved the plan to: infrastructure.tfplan</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat osticket-agent/stats.json | jq .',
                output: [
                    '{',
                    '  "tickets_processed": <span class="output-success">2,847</span>,',
                    '  "avg_response_time": "<span class="output-success">45s</span>",',
                    '  "accuracy_rate": "<span class="output-success">94.3%</span>",',
                    '  "categories": {',
                    '    "network": 1203,',
                    '    "security": 892,',
                    '    "application": 752',
                    '  },',
                    '  "status": "<span class="output-success">operational</span>"',
                    '}'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat testimonial-2.txt',
                output: [
                    '<span class="output-highlight">Enterprise Network Deployment:</span>',
                    '',
                    '"Deployed complex AI-driven network automation across 50+ sites.',
                    'Reduced configuration time by 85% and eliminated human errors.',
                    'Outstanding technical depth and delivery."',
                    '',
                    '- Director of IT Infrastructure, Healthcare Provider'
                ]
            }
        ];

        function addLine(content, className = '') {
            const line = document.createElement('div');
            line.className = 'terminal-line ' + className;
            line.innerHTML = content;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            return line;
        }

        function showSecurityBanner() {
            return new Promise((resolve) => {
                let bannerIndex = 0;
                
                function showNextLine() {
                    if (bannerIndex < securityBanner.length) {
                        const line = document.createElement('div');
                        line.className = 'terminal-line terminal-output banner-line';

                        // Add cursor at the end of the line while drawing
                        const textContent = securityBanner[bannerIndex];
                        line.innerHTML = textContent + '<span class="terminal-cursor"></span>';
                        terminal.appendChild(line);

                        // Remove cursor after brief pause
                        setTimeout(() => {
                            const cursor = line.querySelector('.terminal-cursor');
                            if (cursor) cursor.remove();

                            bannerIndex++;
                            // Faster display for banner lines
                            setTimeout(showNextLine, 50);
                        }, 100);
                    } else {
                        // Banner complete, add blinking cursor
                        const cursorLine = document.createElement('div');
                        cursorLine.className = 'terminal-line';
                        cursorLine.innerHTML = '<span class="terminal-cursor"></span>';
                        terminal.appendChild(cursorLine);

                        // Wait then clear and start matrix
                        setTimeout(() => {
                            terminal.innerHTML = '';
                            showBanner = false;

                            // Start matrix effect after banner clears
                            if (typeof startMatrix === 'function') {
                                startMatrix();
                            }

                            resolve();
                        }, 4000);
                    }
                }
                
                showNextLine();
            });
        }

        // Asteroids game implementation
        function startAsteroidsGame() {
            // Remove interactive prompt if it exists
            if (currentInputLine) {
                currentInputLine.remove();
                currentInputLine = null;
            }

            const WIDTH = 24;
            const HEIGHT = 8;
            let gameActive = true;
            let score = 0;
            let lives = 3;
            let level = 1;
            let upgradeTime = 4; // Seconds until vector graphics upgrade
            let upgraded = false;
            let invincible = false;
            let invincibleTimer = 0;
            let ship = { x: WIDTH/2, y: HEIGHT/2, angle: 0, vx: 0, vy: 0 };
            let asteroids = [];
            let bullets = [];
            let gameInterval;
            let lastKeyTime = 0;

            // Helper function to create random asteroid shape
            function createAsteroidShape() {
                const sides = 7 + Math.floor(Math.random() * 6); // 7-12 sides
                const shape = [];
                for (let i = 0; i < sides; i++) {
                    const radiusVariation = 0.7 + Math.random() * 0.6; // 0.7 to 1.3
                    shape.push(radiusVariation);
                }
                return shape;
            }

            // Helper function to spawn asteroid safely (not near ship)
            function spawnAsteroid(x, y, vx, vy, size, shape) {
                const safeZone = 100; // pixels
                const centerX = WIDTH / 2;
                const centerY = HEIGHT / 2;

                // If position not specified, find safe spawn
                if (x === undefined) {
                    do {
                        x = Math.random() * WIDTH;
                        y = Math.random() * HEIGHT;
                    } while (Math.abs(x - centerX) < safeZone/10 && Math.abs(y - centerY) < safeZone/10);
                }

                asteroids.push({
                    x: x || Math.random() * WIDTH,
                    y: y || Math.random() * HEIGHT,
                    vx: vx || (Math.random() - 0.5) * 0.4, // Slower for retro players
                    vy: vy || (Math.random() - 0.5) * 0.4,
                    size: size || 3,
                    shape: shape || createAsteroidShape()
                });
            }

            // Initialize asteroids with safe spawn (fewer for small screen)
            for (let i = 0; i < 3; i++) {
                spawnAsteroid();
            }

            const shipChars = ['^', '>', 'v', '<'];

            function renderGame() {
                const field = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(' '));

                // Draw asteroids
                asteroids.forEach(ast => {
                    const x = Math.floor(ast.x);
                    const y = Math.floor(ast.y);
                    if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
                        field[y][x] = ast.size === 3 ? 'O' : ast.size === 2 ? 'o' : '*';
                    }
                });

                // Draw bullets
                bullets.forEach(bullet => {
                    const x = Math.floor(bullet.x);
                    const y = Math.floor(bullet.y);
                    if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
                        field[y][x] = '·';
                    }
                });

                // Draw ship
                const sx = Math.floor(ship.x);
                const sy = Math.floor(ship.y);
                if (sx >= 0 && sx < WIDTH && sy >= 0 && sy < HEIGHT) {
                    field[sy][sx] = shipChars[ship.angle % 4];
                }

                // Render inline - minimal oversimplified version
                let gameContainer = document.getElementById('asteroids-text-game');
                if (!gameContainer) {
                    gameContainer = document.createElement('div');
                    gameContainer.id = 'asteroids-text-game';
                    gameContainer.style.fontFamily = 'monospace';
                    gameContainer.style.lineHeight = '1.2';
                    gameContainer.style.whiteSpace = 'pre';
                    gameContainer.style.color = '#888';
                    terminal.appendChild(gameContainer);
                }

                gameContainer.textContent = field.map(row => row.join('')).join('\n');
                terminal.scrollTop = terminal.scrollHeight;
            }

            // Vector graphics upgrade
            let canvas, ctx, particles = [];
            let audioContext, sounds = {};
            let stars = [];
            let screenShake = 0;

            function triggerUpgrade() {
                upgraded = true;
                clearInterval(gameInterval);

                // Remove ASCII keyboard handler
                document.removeEventListener('keydown', asteroidKeyHandler);

                // Hide terminal and create full-screen game with matrix
                terminal.style.display = 'none';

                // Start matrix effect
                if (typeof startMatrix === 'function') {
                    startMatrix();
                }

                // Create game container
                const gameContainer = document.createElement('div');
                gameContainer.id = 'asteroids-container';
                gameContainer.style.position = 'fixed';
                gameContainer.style.top = '50%';
                gameContainer.style.left = '50%';
                gameContainer.style.transform = 'translate(-50%, -50%)';
                gameContainer.style.zIndex = '100';
                document.body.appendChild(gameContainer);

                // Create canvas with CRT effects
                canvas = document.createElement('canvas');
                canvas.width = 700;
                canvas.height = 480;
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                canvas.style.border = '2px solid #39ff14';
                canvas.style.borderRadius = '4px';
                canvas.style.background = '#000';
                canvas.style.boxShadow = '0 0 30px rgba(57, 255, 20, 0.6), inset 0 0 60px rgba(0, 255, 0, 0.1)';
                gameContainer.appendChild(canvas);
                ctx = canvas.getContext('2d');

                // Add scanline overlay
                const scanlineCanvas = document.createElement('canvas');
                scanlineCanvas.width = 700;
                scanlineCanvas.height = 480;
                scanlineCanvas.style.position = 'absolute';
                scanlineCanvas.style.top = '0';
                scanlineCanvas.style.left = '0';
                scanlineCanvas.style.pointerEvents = 'none';
                const scanCtx = scanlineCanvas.getContext('2d');
                for (let y = 0; y < scanlineCanvas.height; y += 3) {
                    scanCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    scanCtx.fillRect(0, y, scanlineCanvas.width, 1);
                }
                gameContainer.appendChild(scanlineCanvas);

                    // NOW convert ship and asteroids for vector mode
                    ship.angle = ship.angle * (Math.PI / 2); // Convert from 0-3 to radians
                    ship.x = canvas.width / 2; // Center ship
                    ship.y = canvas.height / 2;
                    ship.vx = 0;
                    ship.vy = 0;

                    // Clear asteroids and respawn safely for vector mode
                    const oldScore = score;
                    asteroids = [];
                    bullets = [];

                    // Spawn asteroids for vector mode with safe zone
                    for (let i = 0; i < (3 + level); i++) {
                        const safeZone = 150;
                        let x, y;
                        do {
                            x = Math.random() * canvas.width;
                            y = Math.random() * canvas.height;
                        } while (Math.abs(x - canvas.width/2) < safeZone && Math.abs(y - canvas.height/2) < safeZone);

                        asteroids.push({
                            x, y,
                            vx: (Math.random() - 0.5) * 2.4,
                            vy: (Math.random() - 0.5) * 2.4,
                            size: 25 + Math.random() * 5,
                            shape: createAsteroidShape()
                        });
                    }
                    score = oldScore;

                    // Initialize starfield
                    for (let i = 0; i < 50; i++) {
                        stars.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            brightness: Math.random()
                        });
                    }

                    // Initialize audio
                    initAudio();

                    // Add vector keyboard handlers
                    document.addEventListener('keydown', vectorKeyHandler);
                    document.addEventListener('keyup', vectorKeyHandler);

                    // Start vector game loop immediately
                    gameInterval = setInterval(updateVectorGame, 16); // ~60fps
            }

            function initAudio() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create sound functions
                    sounds.shoot = () => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.type = 'square'; // Square wave for retro sound
                        // Frequency sweep from high to low for "pew pew"
                        osc.frequency.setValueAtTime(1200, audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.08);
                        gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.08);
                    };

                    sounds.explode = () => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(200, audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.3);
                        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        osc.start();
                        osc.stop(audioContext.currentTime + 0.3);
                    };

                    sounds.thrust = () => {
                        // Create pink noise buffer for thruster
                        const bufferSize = audioContext.sampleRate * 0.15;
                        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const output = buffer.getChannelData(0);

                        // Generate pink noise (filtered white noise)
                        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                        for (let i = 0; i < bufferSize; i++) {
                            const white = Math.random() * 2 - 1;
                            b0 = 0.99886 * b0 + white * 0.0555179;
                            b1 = 0.99332 * b1 + white * 0.0750759;
                            b2 = 0.96900 * b2 + white * 0.1538520;
                            b3 = 0.86650 * b3 + white * 0.3104856;
                            b4 = 0.55000 * b4 + white * 0.5329522;
                            b5 = -0.7616 * b5 - white * 0.0168980;
                            output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                            b6 = white * 0.115926;
                        }

                        const noise = audioContext.createBufferSource();
                        noise.buffer = buffer;

                        const noiseGain = audioContext.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(audioContext.destination);

                        // Add low frequency rumble
                        const rumble = audioContext.createOscillator();
                        rumble.type = 'sawtooth';
                        rumble.frequency.value = 60;
                        const rumbleGain = audioContext.createGain();
                        rumble.connect(rumbleGain);
                        rumbleGain.connect(audioContext.destination);

                        // Envelope
                        noiseGain.gain.setValueAtTime(0.08, audioContext.currentTime);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
                        rumbleGain.gain.setValueAtTime(0.03, audioContext.currentTime);
                        rumbleGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);

                        noise.start();
                        rumble.start();
                        noise.stop(audioContext.currentTime + 0.15);
                        rumble.stop(audioContext.currentTime + 0.15);
                    };
                } catch (e) {
                    console.log('Audio not supported');
                    sounds = { shoot: ()=>{}, explode: ()=>{}, thrust: ()=>{} };
                }
            }

            function createParticles(x, y, count = 10) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        life: 1.0
                    });
                }
            }

            function renderVectorGame() {
                // Apply screen shake
                ctx.save();
                if (screenShake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * screenShake,
                        (Math.random() - 0.5) * screenShake
                    );
                    screenShake *= 0.9;
                }

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw starfield
                stars.forEach(star => {
                    star.brightness += (Math.random() - 0.5) * 0.1;
                    star.brightness = Math.max(0.3, Math.min(1, star.brightness));
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * 0.6})`;
                    ctx.fillRect(star.x, star.y, 1, 1);
                });

                // Draw particles with glow
                particles.forEach(p => {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `rgba(0, 255, 0, ${p.life})`;
                    ctx.fillStyle = `rgba(0, 255, 0, ${p.life})`;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                });
                ctx.shadowBlur = 0;

                // Draw asteroids with random shapes and phosphor glow
                asteroids.forEach(ast => {
                    // Phosphor glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const sides = ast.shape ? ast.shape.length : 8;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const radiusVar = ast.shape ? ast.shape[i] : 1;
                        const radius = ast.size * radiusVar;
                        const x = ast.x + Math.cos(angle) * radius;
                        const y = ast.y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                });

                // Draw bullets with phosphor glow
                bullets.forEach(b => {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff00';
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });

                // Draw ship (with invincibility flash and phosphor glow)
                if (!invincible || Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.save();
                    ctx.translate(ship.x, ship.y);
                    ctx.rotate(ship.angle);
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(-10, 10);
                    ctx.lineTo(0, 5);
                    ctx.lineTo(10, 10);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Thrust flame with glow
                    if (keys.ArrowUp) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff6600';
                        ctx.fillStyle = '#ff6600';
                        ctx.beginPath();
                        ctx.moveTo(-5, 10);
                        ctx.lineTo(0, 20 + Math.random() * 5);
                        ctx.lineTo(5, 10);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    ctx.restore();
                }

                // Draw lives with glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ff00';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                for (let i = 0; i < lives - 1; i++) {
                    ctx.save();
                    ctx.translate(30 + i * 25, canvas.height - 30);
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(-6, 6);
                    ctx.lineTo(0, 3);
                    ctx.lineTo(6, 6);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.shadowBlur = 0;

                ctx.restore(); // Restore from screen shake

                // Score and Level with phosphor glow
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#00ff00';
                ctx.fillStyle = '#00ff00';
                ctx.font = '20px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('SCORE: ' + score, 30, 30);
                ctx.fillText('LEVEL: ' + level, 30, 55);
                ctx.fillText('H: HYPERSPACE', canvas.width - 180, 30);
                ctx.fillText('Q: QUIT', canvas.width - 100, 55);
                ctx.shadowBlur = 0;

                if (!gameActive) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff5f56';
                    ctx.font = '48px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.font = '24px monospace';
                    ctx.fillStyle = '#39ff14';
                    ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
                }
            }

            let keys = {};
            function vectorKeyHandler(e) {
                keys[e.key] = e.type === 'keydown';

                // Hyperspace
                if ((e.key === 'h' || e.key === 'H') && e.type === 'keydown' && !keys.hyperUsed) {
                    keys.hyperUsed = true;
                    createParticles(ship.x, ship.y, 10);
                    ship.x = Math.random() * canvas.width;
                    ship.y = Math.random() * canvas.height;
                    ship.vx = 0;
                    ship.vy = 0;
                    createParticles(ship.x, ship.y, 10);

                    // 10% chance of destruction
                    if (Math.random() < 0.1) {
                        lives--;
                        if (lives > 0) {
                            respawnShip();
                        } else {
                            gameActive = false;
                            clearInterval(gameInterval);
                        }
                    }
                    setTimeout(() => keys.hyperUsed = false, 500);
                }

                if (e.key === 'q' || e.key === 'Q') {
                    gameActive = false;
                    clearInterval(gameInterval);
                    document.removeEventListener('keydown', vectorKeyHandler);
                    document.removeEventListener('keyup', vectorKeyHandler);

                    // Clean up game container
                    const gameContainer = document.getElementById('asteroids-container');
                    if (gameContainer) gameContainer.remove();

                    // Show terminal and return to auto mode
                    terminal.style.display = 'block';
                    terminal.innerHTML = '';
                    setTimeout(() => {
                        returnToAutoMode();
                    }, 100);
                }
                e.preventDefault();
            }

            function respawnShip() {
                ship.x = canvas.width / 2;
                ship.y = canvas.height / 2;
                ship.vx = 0;
                ship.vy = 0;
                ship.angle = 0;
                invincible = true;
                invincibleTimer = 2500; // 2.5 seconds
            }

            function updateVectorGame() {
                if (!gameActive) {
                    renderVectorGame();
                    return;
                }

                // Update invincibility
                if (invincible) {
                    invincibleTimer -= 16;
                    if (invincibleTimer <= 0) {
                        invincible = false;
                    }
                }

                // Ship controls - smooth 360° rotation
                if (keys.ArrowLeft) ship.angle -= 0.1;
                if (keys.ArrowRight) ship.angle += 0.1;
                if (keys.ArrowUp) {
                    ship.vx += Math.sin(ship.angle) * 0.3;
                    ship.vy -= Math.cos(ship.angle) * 0.3;
                    if (sounds.thrust && Math.random() > 0.7) sounds.thrust();
                }
                if (keys[' '] && !keys.spaceFired) {
                    keys.spaceFired = true;
                    bullets.push({
                        x: ship.x + Math.sin(ship.angle) * 15,
                        y: ship.y - Math.cos(ship.angle) * 15,
                        vx: Math.sin(ship.angle) * 8,
                        vy: -Math.cos(ship.angle) * 8
                    });
                    if (sounds.shoot) sounds.shoot();
                }
                if (!keys[' ']) keys.spaceFired = false;

                // Update physics
                ship.x += ship.vx;
                ship.y += ship.vy;
                ship.vx *= 0.98;
                ship.vy *= 0.98;

                // Wrap
                if (ship.x < 0) ship.x = canvas.width;
                if (ship.x > canvas.width) ship.x = 0;
                if (ship.y < 0) ship.y = canvas.height;
                if (ship.y > canvas.height) ship.y = 0;

                // Update asteroids
                asteroids.forEach(ast => {
                    ast.x += ast.vx;
                    ast.y += ast.vy;
                    if (ast.x < 0) ast.x = canvas.width;
                    if (ast.x > canvas.width) ast.x = 0;
                    if (ast.y < 0) ast.y = canvas.height;
                    if (ast.y > canvas.height) ast.y = 0;
                });

                // Update bullets
                bullets = bullets.filter(b => {
                    b.x += b.vx;
                    b.y += b.vy;
                    return b.x >= 0 && b.x <= canvas.width && b.y >= 0 && b.y <= canvas.height;
                });

                // Update particles
                particles = particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    return p.life > 0;
                });

                // Collisions
                bullets.forEach((b, bi) => {
                    asteroids.forEach((ast, ai) => {
                        const dx = b.x - ast.x;
                        const dy = b.y - ast.y;
                        if (dx*dx + dy*dy < ast.size * ast.size) {
                            bullets.splice(bi, 1);
                            const oldSize = ast.size;
                            asteroids.splice(ai, 1);
                            score += Math.floor((30 - oldSize) * 2);
                            createParticles(ast.x, ast.y, 15);
                            screenShake = 5;
                            if (sounds.explode) sounds.explode();

                            // Check for extra life at 10,000 points
                            if (score >= 10000 && score - Math.floor((30 - oldSize) * 2) < 10000) {
                                lives++;
                            }

                            if (oldSize > 10) {
                                for (let i = 0; i < 2; i++) {
                                    asteroids.push({
                                        x: ast.x,
                                        y: ast.y,
                                        vx: (Math.random() - 0.5) * 3,
                                        vy: (Math.random() - 0.5) * 3,
                                        size: oldSize / 2,
                                        shape: createAsteroidShape()
                                    });
                                }
                            }
                        }
                    });
                });

                // Ship collision (with invincibility check)
                if (!invincible) {
                    asteroids.forEach(ast => {
                        const dx = ship.x - ast.x;
                        const dy = ship.y - ast.y;
                        // More forgiving hitbox (85% of normal)
                        if (dx*dx + dy*dy < (ast.size + 8) * (ast.size + 8)) {
                            lives--;
                            createParticles(ship.x, ship.y, 30);
                            screenShake = 10;
                            if (sounds.explode) sounds.explode();

                            if (lives > 0) {
                                respawnShip();
                            } else {
                                gameActive = false;
                                clearInterval(gameInterval);
                            }
                        }
                    });
                }

                // Level progression - check if all asteroids cleared
                if (asteroids.length === 0) {
                    level++;
                    score += 1000 * level;
                    const newAsteroidCount = Math.min(4 + (level - 1) * 2, 10);

                    // Show level message
                    clearInterval(gameInterval);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '36px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`LEVEL ${level}`, canvas.width / 2, canvas.height / 2);

                    setTimeout(() => {
                        // Spawn new asteroids for next level
                        for (let i = 0; i < newAsteroidCount; i++) {
                            const safeZone = 150;
                            let x, y;
                            do {
                                x = Math.random() * canvas.width;
                                y = Math.random() * canvas.height;
                            } while (Math.abs(x - canvas.width/2) < safeZone && Math.abs(y - canvas.height/2) < safeZone);

                            asteroids.push({
                                x, y,
                                vx: (Math.random() - 0.5) * 2.4, // Slower for retro players
                                vy: (Math.random() - 0.5) * 2.4,
                                size: 25 + Math.random() * 5, // Large asteroids
                                shape: createAsteroidShape()
                            });
                        }
                        gameInterval = setInterval(updateVectorGame, 16);
                    }, 2000);
                }

                renderVectorGame();
            }

            function updateGame() {
                if (!gameActive) return;

                // Check for upgrade (silent - no countdown display)
                if (!upgraded && upgradeTime > 0) {
                    upgradeTime -= 0.1;
                    if (upgradeTime <= 0) {
                        upgradeTime = 0;
                        // Clean up text version
                        const textGame = document.getElementById('asteroids-text-game');
                        if (textGame) textGame.remove();
                        triggerUpgrade();
                        return;
                    }
                }

                // Update ship position
                ship.x += ship.vx;
                ship.y += ship.vy;
                ship.vx *= 0.98;
                ship.vy *= 0.98;

                // Wrap ship
                if (ship.x < 0) ship.x = WIDTH - 1;
                if (ship.x >= WIDTH) ship.x = 0;
                if (ship.y < 0) ship.y = HEIGHT - 1;
                if (ship.y >= HEIGHT) ship.y = 0;

                // Update asteroids
                asteroids.forEach(ast => {
                    ast.x += ast.vx;
                    ast.y += ast.vy;
                    if (ast.x < 0) ast.x = WIDTH - 1;
                    if (ast.x >= WIDTH) ast.x = 0;
                    if (ast.y < 0) ast.y = HEIGHT - 1;
                    if (ast.y >= HEIGHT) ast.y = 0;
                });

                // Update bullets
                bullets = bullets.filter(bullet => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    return bullet.x >= 0 && bullet.x < WIDTH && bullet.y >= 0 && bullet.y < HEIGHT;
                });

                // Check bullet-asteroid collisions
                bullets.forEach((bullet, bi) => {
                    asteroids.forEach((ast, ai) => {
                        const dx = bullet.x - ast.x;
                        const dy = bullet.y - ast.y;
                        if (dx*dx + dy*dy < ast.size * ast.size) {
                            bullets.splice(bi, 1);
                            const oldSize = ast.size;
                            asteroids.splice(ai, 1);
                            score += (4 - oldSize) * 10;

                            // Break into smaller asteroids
                            if (oldSize > 1) {
                                for (let i = 0; i < 2; i++) {
                                    asteroids.push({
                                        x: ast.x,
                                        y: ast.y,
                                        vx: (Math.random() - 0.5) * 0.8,
                                        vy: (Math.random() - 0.5) * 0.8,
                                        size: oldSize - 1
                                    });
                                }
                            }
                        }
                    });
                });

                // Check ship-asteroid collisions
                asteroids.forEach(ast => {
                    const dx = ship.x - ast.x;
                    const dy = ship.y - ast.y;
                    if (dx*dx + dy*dy < ast.size * ast.size) {
                        gameActive = false;
                        clearInterval(gameInterval);
                    }
                });

                // Spawn new asteroids if needed
                if (asteroids.length < 3) {
                    asteroids.push({
                        x: Math.random() * WIDTH,
                        y: Math.random() < 0.5 ? 0 : HEIGHT - 1,
                        vx: (Math.random() - 0.5) * 0.6,
                        vy: (Math.random() - 0.5) * 0.6,
                        size: 3
                    });
                }

                renderGame();
            }

            const asteroidKeyHandler = (e) => {
                const now = Date.now();
                if (now - lastKeyTime < 50) return;
                lastKeyTime = now;

                e.preventDefault();

                switch(e.key) {
                    case 'ArrowLeft':
                        ship.angle = (ship.angle + 3) % 4;
                        break;
                    case 'ArrowRight':
                        ship.angle = (ship.angle + 1) % 4;
                        break;
                    case 'ArrowUp':
                        const thrust = 0.3;
                        const angles = [0, Math.PI/2, Math.PI, -Math.PI/2];
                        ship.vx += Math.sin(angles[ship.angle]) * thrust;
                        ship.vy -= Math.cos(angles[ship.angle]) * thrust;
                        break;
                    case ' ':
                        const speed = 1.5;
                        const angles2 = [0, Math.PI/2, Math.PI, -Math.PI/2];
                        bullets.push({
                            x: ship.x,
                            y: ship.y,
                            vx: Math.sin(angles2[ship.angle]) * speed,
                            vy: -Math.cos(angles2[ship.angle]) * speed
                        });
                        break;
                }
            };

            // Remove existing keyboard handler
            document.removeEventListener('keydown', arguments.callee);
            document.addEventListener('keydown', asteroidKeyHandler);

            renderGame();
            gameInterval = setInterval(updateGame, 100);
        }

        // Command processor for interactive mode
        function processCommand(cmd) {
            const command = cmd.toLowerCase().trim();

            switch(command) {
                case 'help':
                    return [
                        '<span class="output-highlight">Available Commands:</span>',
                        '',
                        '<span class="output-success">Information:</span>',
                        '  help                    - Show this help message',
                        '  whoami                  - Show user information',
                        '  contact                 - Contact information',
                        '  resume                  - Download resume',
                        '  certs                   - View certifications',
                        '',
                        '<span class="output-success">Projects & Skills:</span>',
                        '  projects [--filter ai|network|mobile] - List projects',
                        '  skills                  - Show technical skills',
                        '  services                - Show available services',
                        '',
                        '<span class="output-success">Network Tools:</span>',
                        '  ping <host>             - Network diagnostic tool',
                        '',
                        '<span class="output-success">Games:</span>',
                        '  asteroids               - Play ASCII Asteroids',
                        '',
                        '<span class="output-success">System:</span>',
                        '  clear                   - Clear terminal screen',
                        '  date                    - Show current date and time',
                        '  auto                    - Resume automatic demo'
                    ];

                case 'clear':
                    terminal.innerHTML = '';
                    return null;

                case 'projects':
                case 'projects --filter ai':
                case 'projects --filter network':
                case 'projects --filter mobile':
                    let filter = null;
                    if (cmd.includes('--filter')) {
                        const parts = cmd.split('--filter');
                        if (parts.length > 1) {
                            filter = parts[1].trim().toLowerCase();
                        }
                    }

                    const allProjects = {
                        ai: [
                            '✓ <span class="output-success">ruckus-ztp</span>        [AI-AGENT] [ACTIVE]',
                            '✓ <span class="output-success">osticket-agent</span>   [AI-AGENT] [DEPLOYED]',
                            '✓ <span class="output-success">survival-rag</span>     [AI-RAG] [ACTIVE]'
                        ],
                        network: [
                            '✓ <span class="output-info">r1-api</span>           [SDK] [LIVE]',
                            '✓ <span class="output-info">sz-acl</span>           [NETWORK] [MAINTENANCE]',
                            '✓ <span class="output-success">pflogs</span>          [SECURITY] [ACTIVE]',
                            '✓ <span class="output-info">wifi-test</span>       [NETWORK] [ACTIVE]'
                        ],
                        mobile: [
                            '✓ <span class="output-warning">iOS Apps</span>        [MOBILE] [IN DEVELOPMENT]'
                        ]
                    };

                    let output = [];

                    if (filter === 'ai') {
                        output = ['<span class="output-highlight">AI Projects:</span>', ...allProjects.ai];
                    } else if (filter === 'network') {
                        output = ['<span class="output-highlight">Network Projects:</span>', ...allProjects.network];
                    } else if (filter === 'mobile') {
                        output = ['<span class="output-highlight">Mobile Projects:</span>', ...allProjects.mobile];
                    } else {
                        output = [
                            '<span class="output-highlight">Active Projects:</span>',
                            ...allProjects.ai,
                            ...allProjects.network,
                            ...allProjects.mobile
                        ];
                    }

                    output.push('');
                    output.push('Use --filter [ai|network|mobile] to filter projects.');
                    output.push('Visit /projects.html for detailed information.');

                    return output;

                case 'skills':
                    return [
                        '<span class="output-highlight">Core Skills:</span>',
                        '• Agentic AI System Architecture',
                        '• Large Language Model Integration',
                        '• Network Automation & Zero-Touch Provisioning',
                        '• Swift/iOS Development (ARKit, HealthKit)',
                        '• Cybersecurity (CISSP)',
                        '• Python/JavaScript Development',
                        '• RUCKUS Network Technologies',
                        '',
                        'Visit /skills.html for complete details.'
                    ];

                case 'services':
                    return [
                        '<span class="output-highlight">NeuralConfig Services:</span>',
                        '• AI System Architecture & Consulting',
                        '• Network Automation Solutions',
                        '• Agentic AI Development',
                        '• RAG Implementation & LLM Integration',
                        '• Open Source Network Management Tools',
                        '• iOS Mobile Application Development',
                        '',
                        'Contact: contact@neuralconfig.com'
                    ];

                case 'contact':
                    return [
                        '<span class="output-highlight">NeuralConfig LLC</span>',
                        'Email: contact@neuralconfig.com',
                        'Web: neuralconfig.com',
                        'GitHub: github.com/neuralconfig'
                    ];

                case 'whoami':
                    return [
                        '<span class="output-highlight">AI & Infrastructure Architect</span>',
                        'Specializing in AI-driven network automation',
                        '20+ years network infrastructure experience',
                        'Building intelligent systems at the intersection of AI and networking'
                    ];

                case 'date':
                    const now = new Date();
                    return [now.toString()];

                case 'resume':
                    return [
                        '<span class="output-highlight">Resume Information:</span>',
                        '',
                        'Download PDF: <span class="output-success">Coming Soon</span>',
                        'LinkedIn: <a href="https://linkedin.com/in/neuralconfig" style="color: var(--accent)">linkedin.com/in/neuralconfig</a>',
                        'GitHub: <a href="https://github.com/neuralconfig" style="color: var(--accent)">github.com/neuralconfig</a>',
                        '',
                        'Contact: contact@neuralconfig.com for full resume'
                    ];

                case 'certs':
                case 'certifications':
                    return [
                        '<span class="output-highlight">Active Certifications:</span>',
                        '',
                        '<span class="output-success">Security & AI:</span>',
                        '  • CISSP (ISC2) - Active',
                        '  • Machine Learning Specialization (Stanford/DeepLearning.AI)',
                        '  • Advanced Learning Algorithms (Stanford)',
                        '  • Microsoft Azure AI Fundamentals',
                        '',
                        '<span class="output-success">Cloud & Networking:</span>',
                        '  • Kubernetes and Cloud Native Associate (CNCF)',
                        '  • CCNP (Cisco)',
                        '  • Certified Wireless Design Professional (CWDP)',
                        '  • Certified Wireless Security Professional (CWSP)',
                        '  • IPv6 Forum Certified Engineer (Gold)',
                        '',
                        'Visit /skills.html for complete list'
                    ];

                case 'ping':
                case 'ping 8.8.8.8':
                case 'ping google.com':
                case 'ping neuralconfig.com':
                    const pingHost = cmd.split(' ')[1] || 'neuralconfig.com';
                    return [
                        `PING ${pingHost} (172.67.178.123): 56 data bytes`,
                        '64 bytes from 172.67.178.123: icmp_seq=0 ttl=57 time=12.3 ms',
                        '64 bytes from 172.67.178.123: icmp_seq=1 ttl=57 time=11.8 ms',
                        '64 bytes from 172.67.178.123: icmp_seq=2 ttl=57 time=12.1 ms',
                        '64 bytes from 172.67.178.123: icmp_seq=3 ttl=57 time=11.9 ms',
                        '',
                        `--- ${pingHost} ping statistics ---`,
                        '4 packets transmitted, 4 packets received, 0.0% packet loss',
                        'round-trip min/avg/max/stddev = 11.8/12.0/12.3/0.2 ms'
                    ];

                case 'asteroids':
                    startAsteroidsGame();
                    return null;

                case 'auto':
                    interactiveMode = false;
                    autoMode = true;
                    return [
                        '<span class="output-success">Resuming automatic demonstration...</span>',
                        'Press any key to return to interactive mode.'
                    ];

                case '':
                    return null;

                default:
                    // Check for ping with custom host
                    if (cmd.startsWith('ping ')) {
                        const host = cmd.substring(5).trim();
                        return [
                            `PING ${host} (192.0.2.1): 56 data bytes`,
                            '64 bytes from 192.0.2.1: icmp_seq=0 ttl=57 time=12.3 ms',
                            '64 bytes from 192.0.2.1: icmp_seq=1 ttl=57 time=11.8 ms',
                            '64 bytes from 192.0.2.1: icmp_seq=2 ttl=57 time=12.1 ms',
                            '',
                            `--- ${host} ping statistics ---`,
                            '3 packets transmitted, 3 packets received, 0.0% packet loss'
                        ];
                    }

                    return [`<span class="output-error">Command not found: ${cmd}</span>`, 'Type "help" for available commands.'];
            }
        }

        function typeCommand(prompt, command, callback) {
            if (isTyping || !autoMode || interactiveMode) return;
            isTyping = true;
            
            // Add prompt immediately
            const line = addLine('');
            line.innerHTML = `<span class="terminal-prompt">${prompt}</span><span class="terminal-command"></span><span class="terminal-cursor"></span>`;
            
            const commandSpan = line.querySelector('.terminal-command');
            const cursorSpan = line.querySelector('.terminal-cursor');
            let index = 0;
            
            function typeChar() {
                // Stop if we switched modes
                if (!autoMode || interactiveMode) {
                    if (cursorSpan) cursorSpan.remove();
                    isTyping = false;
                    return;
                }
                
                if (index < command.length) {
                    commandSpan.textContent += command[index];
                    index++;
                    
                    // Variable typing speed for more realistic effect
                    const baseDelay = 40;
                    const variation = Math.random() * 60;
                    const pauseChance = Math.random();
                    let delay = baseDelay + variation;
                    
                    // Occasionally add longer pauses (thinking)
                    if (pauseChance > 0.95) {
                        delay += 200 + Math.random() * 300;
                    }
                    
                    const typeTimeoutId = setTimeout(typeChar, delay);
                    autoTimeouts.push(typeTimeoutId);
                } else {
                    // Remove cursor when done
                    if (cursorSpan) cursorSpan.remove();
                    isTyping = false;
                    if (callback && autoMode && !interactiveMode) callback();
                }
            }
            
            // Start typing after a small delay
            const startTimeoutId = setTimeout(typeChar, 200);
            autoTimeouts.push(startTimeoutId);
        }

        // Interactive mode functions
        function createInteractivePrompt() {
            if (currentInputLine) return; // Already have an active prompt

            currentInputLine = addLine('');
            currentInputLine.innerHTML = '<span class="terminal-prompt">root@neuralconfig:~#</span> <span class="terminal-input"></span><span class="terminal-cursor"></span>';
            currentInputLine.classList.add('interactive-line');
        }

        function updateInputDisplay() {
            if (!currentInputLine) return;
            
            const inputSpan = currentInputLine.querySelector('.terminal-input');
            if (inputSpan) {
                inputSpan.textContent = currentInput;
            }
        }

        function executeInteractiveCommand() {
            // Guard against null currentInputLine (race condition during mode switch)
            if (!currentInputLine) return;

            // Remove cursor from current line
            const cursor = currentInputLine.querySelector('.terminal-cursor');
            if (cursor) cursor.remove();
            
            if (!currentInput.trim()) {
                // For empty input, just create a new prompt
                currentInput = '';
                currentInputLine = null;
                setTimeout(createInteractivePrompt, 100);
                return;
            }
            
            // Add command to history
            commandHistory.push(currentInput);
            historyIndex = commandHistory.length;
            
            // Special handling for 'auto' command
            if (currentInput.toLowerCase().trim() === 'auto') {
                currentInput = '';
                currentInputLine = null;
                returnToAutoMode();
                return;
            }
            
            // Process the command
            const output = processCommand(currentInput);
            
            if (output) {
                output.forEach(line => {
                    addLine(line, 'terminal-output');
                });
            }
            
            // Clear input and create new prompt if still in interactive mode
            currentInput = '';
            currentInputLine = null;
            
            if (interactiveMode) {
                setTimeout(createInteractivePrompt, 100);
            }
        }

        function resetInteractiveTimeout() {
            // Clear existing timeouts
            if (interactiveTimeout) {
                clearTimeout(interactiveTimeout);
            }
            if (window.interactiveWarningTimeout) {
                clearTimeout(window.interactiveWarningTimeout);
            }

            // Set warning at 55 seconds (5 seconds before timeout)
            window.interactiveWarningTimeout = setTimeout(() => {
                if (interactiveMode) {
                    addLine('<span class="output-warning">timeout warning: auto-logout in 5 seconds due to inactivity</span>', 'terminal-output');
                    if (currentInputLine) {
                        // Re-add the prompt after warning
                        currentInputLine.remove();
                        currentInputLine = null;
                        setTimeout(() => {
                            if (interactiveMode) createInteractivePrompt();
                        }, 50);
                    }
                }
            }, 55000);

            // Set 60-second timeout
            interactiveTimeout = setTimeout(() => {
                if (interactiveMode) {
                    addLine('<span class="output-error">auto-logout: timed out waiting for input</span>', 'terminal-output');
                    setTimeout(() => {
                        returnToAutoMode();
                    }, 1000);
                }
            }, 60000);
        }

        function returnToAutoMode() {
            interactiveMode = false;
            autoMode = true;
            currentInput = '';
            currentInputLine = null;

            // Clear interactive timeouts
            if (interactiveTimeout) {
                clearTimeout(interactiveTimeout);
                interactiveTimeout = null;
            }
            if (window.interactiveWarningTimeout) {
                clearTimeout(window.interactiveWarningTimeout);
                window.interactiveWarningTimeout = null;
            }
            
            // Resume auto demo
            setTimeout(() => {
                if (autoMode && !interactiveMode) {
                    showCommand();
                }
            }, 500);
        }

        function switchToInteractive() {
            if (interactiveMode) return;
            
            // Stop auto mode immediately
            autoMode = false;
            interactiveMode = true;
            isTyping = false;
            
            // Cancel all pending auto timeouts
            autoTimeouts.forEach(id => clearTimeout(id));
            autoTimeouts = [];
            
            // Remove any existing cursors
            const existingCursors = terminal.querySelectorAll('.terminal-cursor');
            existingCursors.forEach(cursor => cursor.remove());
            
            // Start interactive timeout
            resetInteractiveTimeout();
            
            // Add a message about switching to interactive mode
            addLine('<span class="output-success">Interactive mode activated. Type "help" for commands or "auto" to resume demo.</span>', 'terminal-output');
            
            setTimeout(createInteractivePrompt, 500);
        }

        function showNextCommandWithPrompt() {
            if (!autoMode || interactiveMode || commandIndex >= commands.length) return;

            const cmd = commands[commandIndex];
            const promptLine = addLine('');
            promptLine.innerHTML = `<span class="terminal-prompt">${cmd.prompt}</span><span class="terminal-command"></span><span class="terminal-cursor"></span>`;

            // Pause with cursor visible, then type the command
            const pauseTimeoutId = setTimeout(() => {
                if (!autoMode || interactiveMode) return;

                // Type the command character by character
                const commandSpan = promptLine.querySelector('.terminal-command');
                const cursorSpan = promptLine.querySelector('.terminal-cursor');
                let charIndex = 0;

                function typeNextChar() {
                    if (!autoMode || interactiveMode) {
                        if (cursorSpan) cursorSpan.remove();
                        return;
                    }

                    if (charIndex < cmd.command.length) {
                        commandSpan.textContent += cmd.command[charIndex];
                        charIndex++;
                        const charTimeoutId = setTimeout(typeNextChar, 40 + Math.random() * 60);
                        autoTimeouts.push(charTimeoutId);
                    } else {
                        // Command finished typing, remove cursor and show output
                        if (cursorSpan) cursorSpan.remove();

                        // Show output
                        cmd.output.forEach((line, index) => {
                            const outputTimeoutId = setTimeout(() => {
                                if (autoMode && !interactiveMode) {
                                    addLine(line, 'terminal-output');
                                }
                            }, index * outputDelay);
                            autoTimeouts.push(outputTimeoutId);
                        });

                        // Continue to next command
                        const continueTimeoutId = setTimeout(() => {
                            if (!autoMode || interactiveMode) return;
                            commandIndex++;

                            if (commandIndex < commands.length) {
                                // Show next prompt immediately and repeat
                                showNextCommandWithPrompt();
                            } else {
                                // Restart from beginning
                                const restartTimeoutId = setTimeout(() => {
                                    if (autoMode && !interactiveMode) {
                                        terminal.innerHTML = '';
                                        commandIndex = 0;
                                        showCommand();
                                    }
                                }, commandDelay);
                                autoTimeouts.push(restartTimeoutId);
                            }
                        }, cmd.output.length * outputDelay + 200);
                        autoTimeouts.push(continueTimeoutId);
                    }
                }

                typeNextChar();
            }, commandDelay);
            autoTimeouts.push(pauseTimeoutId);
        }

        function showCommand() {
            // Stop if we're not in auto mode
            if (!autoMode || interactiveMode) {
                return;
            }
            
            if (commandIndex >= commands.length) {
                // Clear terminal and restart
                const timeoutId = setTimeout(() => {
                    if (autoMode && !interactiveMode) {
                        terminal.innerHTML = '';
                        commandIndex = 0;
                        showCommand();
                    }
                }, commandDelay);
                autoTimeouts.push(timeoutId);
                return;
            }

            const cmd = commands[commandIndex];
            
            // Type the command with prompt appearing immediately
            typeCommand(cmd.prompt, cmd.command, () => {
                if (!autoMode || interactiveMode) return; // Check again after typing
                
                // Show output immediately after command is typed (no delay)
                cmd.output.forEach((line, index) => {
                    const timeoutId = setTimeout(() => {
                        if (autoMode && !interactiveMode) {
                            addLine(line, 'terminal-output');
                        }
                    }, index * outputDelay);
                    autoTimeouts.push(timeoutId);
                });
                
                // After all output is shown, show next prompt immediately
                const timeoutId = setTimeout(() => {
                    if (!autoMode || interactiveMode) return;

                    commandIndex++;

                    if (commandIndex < commands.length) {
                        // Use the new function to show prompt immediately and continue
                        showNextCommandWithPrompt();
                    } else {
                        // Restart from beginning
                        const restartTimeoutId = setTimeout(() => {
                            if (autoMode && !interactiveMode) {
                                terminal.innerHTML = '';
                                commandIndex = 0;
                                showCommand();
                            }
                        }, commandDelay);
                        autoTimeouts.push(restartTimeoutId);
                    }
                }, cmd.output.length * outputDelay + 200); // Small buffer after output
                autoTimeouts.push(timeoutId);
            });
        }

        // Keep only last N lines to prevent memory issues
        function limitTerminalHistory() {
            const maxLines = 30;
            while (terminal.children.length > maxLines) {
                terminal.removeChild(terminal.firstChild);
            }
        }

        // Keyboard and interaction event handlers
        document.addEventListener('keydown', function(e) {
            if (!interactiveMode && autoMode) {
                // Switch to interactive mode on any key press
                e.preventDefault();
                switchToInteractive();
                return;
            }
            
            if (!interactiveMode) return;
            
            // Reset timeout on ANY keypress in interactive mode
            resetInteractiveTimeout();
            
            switch(e.key) {
                case 'Enter':
                    e.preventDefault();
                    executeInteractiveCommand();
                    break;
                    
                case 'Backspace':
                    e.preventDefault();
                    if (currentInput.length > 0) {
                        currentInput = currentInput.slice(0, -1);
                        updateInputDisplay();
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (commandHistory.length > 0 && historyIndex > 0) {
                        historyIndex--;
                        currentInput = commandHistory[historyIndex];
                        updateInputDisplay();
                    }
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        currentInput = commandHistory[historyIndex];
                        updateInputDisplay();
                    } else if (historyIndex === commandHistory.length - 1) {
                        historyIndex = commandHistory.length;
                        currentInput = '';
                        updateInputDisplay();
                    }
                    break;
                    
                default:
                    // Handle regular character input
                    if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                        e.preventDefault();
                        currentInput += e.key;
                        updateInputDisplay();
                    }
                    break;
            }
        });

        // Mobile support - tap to activate
        terminal.addEventListener('click', function() {
            if (!interactiveMode && autoMode) {
                switchToInteractive();
            }
        });

        // Prevent default touch behaviors that might interfere
        terminal.addEventListener('touchstart', function(e) {
            if (!interactiveMode && autoMode) {
                e.preventDefault();
                switchToInteractive();
            }
        });

        // Start the terminal simulation
        setTimeout(async () => {
            if (showBanner) {
                await showSecurityBanner();
            }
            showCommand();
        }, 1000);

        // Clean up terminal periodically
        setInterval(limitTerminalHistory, 5000);

        // Pause when tab is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Could pause animations here if needed
            }
        });
    </script>
</body>
</html>