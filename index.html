<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralConfig | AI Consulting & Software Development</title>
    <meta name="description" content="AI consulting and software development services. Agentic AI, RAG systems, network automation. 20+ years infrastructure experience, Stanford ML, CISSP.">
    <meta name="keywords" content="AI consulting, AI software development, agentic AI, autonomous agents, RAG systems, LLM integration, network automation, CISSP">
    <meta name="author" content="NeuralConfig LLC">

    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://neuralconfig.com/">
    <meta property="og:title" content="NeuralConfig | AI Consulting & Software Development">
    <meta property="og:description" content="AI consulting and software development services. Agentic AI, RAG systems, and network automation expertise.">
    <meta property="og:image" content="https://neuralconfig.com/images/og-home.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="NeuralConfig">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@neuralconfig">
    <meta name="twitter:title" content="NeuralConfig | AI Consulting & Software Development">
    <meta name="twitter:description" content="AI consulting and software development services. Agentic AI, RAG systems, and network automation expertise.">
    <meta name="twitter:image" content="https://neuralconfig.com/images/og-home.png">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://neuralconfig.com/">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="styles.css">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "ProfessionalService",
        "name": "NeuralConfig LLC",
        "description": "AI consulting and software development services specializing in agentic AI systems, RAG implementations, and network automation.",
        "url": "https://neuralconfig.com",
        "logo": "https://neuralconfig.com/images/logo.png",
        "serviceType": ["AI Consulting", "Software Development", "iOS App Development"],
        "areaServed": "Worldwide",
        "sameAs": [
            "https://github.com/neuralconfig"
        ],
        "contactPoint": {
            "@type": "ContactPoint",
            "email": "contact@neuralconfig.com",
            "contactType": "sales"
        }
    }
    </script>
    <style>
        /* Skip link for keyboard accessibility - visible only on focus */
        .skip-link {
            position: absolute !important;
            left: -9999px !important;
            z-index: 9999 !important;
            padding: 1rem !important;
            background: #569cd6 !important;
            color: #000 !important;
            text-decoration: none !important;
            font-weight: bold !important;
        }

        .skip-link:focus {
            left: 0 !important;
            top: 0 !important;
        }

        /* Visually hidden but accessible to screen readers and search engines */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Home page specific styles */
        .home-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            padding-top: 80px; /* Add space for nav bar */
        }

        .hero-content {
            width: 100%;
            max-width: 1000px;
        }

        .brackets {
            color: var(--accent);
        }

        .terminal {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            margin: 0 auto;
            padding: 1.5rem;
            width: 100%;
            max-width: 900px;
            min-height: 450px;
            max-height: 600px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.8s ease forwards;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            font-family: 'IBM Plex Mono', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            text-align: left;
            position: relative;
        }

        /* Very subtle phosphor glow */
        .terminal .terminal-line {
            text-shadow: 0 0 1px currentColor;
        }

        /* Medium scanlines */
        .terminal::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            border-radius: 4px;
        }

        .terminal-line {
            margin: 0.2rem 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            text-align: left;
        }

        .terminal-prompt {
            color: #39ff14;
            font-weight: bold;
        }

        .terminal-command {
            color: #00ff00;
        }

        .terminal-output {
            color: #888;
            margin-left: 0;
        }

        .terminal-cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background: #00ff00;
            animation: blink 1s infinite;
            vertical-align: text-bottom;
            margin-left: 2px;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
            z-index: -1;
        }

        /* Scrollbar styling */
        .terminal::-webkit-scrollbar {
            width: 8px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .terminal::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        /* Output styling */
        .output-highlight {
            color: #39ff14;
        }

        .output-error {
            color: #ff5f56;
        }

        .output-warning {
            color: #ffbd2e;
        }

        .output-info {
            color: #00bfff;
        }

        .output-success {
            color: #27c93f;
        }

        .output-dim {
            opacity: 0.7;
        }

        .banner-line {
            color: #39ff14 !important;
        }

        /* Interactive mode styles */
        .interactive-line {
            position: relative;
        }
        
        .terminal-input {
            color: #00ff00;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .home-container {
                padding: 1rem;
                padding-top: 80px;
            }

            .terminal {
                font-size: 0.8rem;
                line-height: 1.5;
                min-height: 350px;
                max-height: 70vh;
                padding: 1rem;
            }

            .terminal-line {
                word-break: break-word;
                line-height: 1.6;
            }
            
            /* Make touch targets larger on mobile */
            .terminal {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                cursor: pointer;
            }
            
            /* Prevent zoom on focus */
            input, textarea, select {
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .terminal {
                font-size: 0.75rem;
                padding: 0.8rem;
                min-height: 300px;
            }
            
            .hero-content {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Skip to main content link for keyboard users -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <canvas class="matrix-bg" id="matrixCanvas" aria-hidden="true"></canvas>

    <nav class="nav-bar" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <a href="index.html" class="nav-logo" aria-label="NeuralConfig Home">neural<span class="brackets" aria-hidden="true">[</span>config<span class="brackets" aria-hidden="true">]</span></a>
            <div class="nav-links" role="list">
                <a href="skills.html" class="nav-link" role="listitem">about</a>
                <a href="projects.html" class="nav-link" role="listitem">projects</a>
                <a href="https://github.com/neuralconfig" class="nav-link external" role="listitem" target="_blank" rel="noopener noreferrer" aria-label="GitHub (opens in new tab)">github</a>
            </div>
        </div>
    </nav>

    <main id="main-content" role="main">
        <h1 class="sr-only">NeuralConfig - AI Consulting and Software Development Services</h1>
        <div class="home-container">
            <div class="hero-content">
                <div class="terminal" id="terminal-output" role="log" aria-live="polite" aria-label="Terminal output">
                <!-- Terminal content will be dynamically inserted here -->
            </div>
        </div>
    </div>
    </main>

    <footer class="footer" role="contentinfo">
        © 2025 NeuralConfig LLC | <a href="mailto:contact@neuralconfig.com" style="color: var(--accent); text-decoration: none;">contact@neuralconfig.com</a>
    </footer>

    <script src="matrix.js"></script>
    <script>
        // Terminal simulation
        const terminal = document.getElementById('terminal-output');
        let commandIndex = 0;
        let charIndex = 0;
        let isTyping = false;
        let currentLine = null;
        let typingSpeed = 40;
        let commandDelay = 3000;
        let outputDelay = 100;
        let showBanner = true;
        let interactiveMode = false;
        let autoMode = true;
        let currentInput = '';
        let commandHistory = [];
        let historyIndex = -1;
        let currentInputLine = null;
        let autoTimeouts = [];
        let interactiveTimeout = null;
        
        // Welcome banner content - different versions for mobile and desktop
        const isMobile = window.innerWidth < 768;

        // Calculate terminal width in characters for responsive banner
        function getTerminalWidth() {
            const terminal = document.getElementById('terminal');
            if (!terminal) return 80; // Fallback width

            const testSpan = document.createElement('span');
            testSpan.textContent = '█';
            testSpan.style.visibility = 'hidden';
            testSpan.style.position = 'absolute';
            terminal.appendChild(testSpan);
            const charWidth = testSpan.offsetWidth;
            terminal.removeChild(testSpan);

            if (!charWidth || charWidth === 0) return 80; // Fallback if calculation fails

            const terminalWidth = terminal.clientWidth - 48; // Account for padding (1.5rem * 2 = 48px)
            const calculatedWidth = Math.floor(terminalWidth / charWidth);

            return calculatedWidth > 0 ? calculatedWidth : 80;
        }

        function createBanner() {
            const terminalWidth = getTerminalWidth();
            const border = '█'.repeat(terminalWidth);

            if (isMobile) {
                return [
                    border,
                    '',
                    '         NEURALCONFIG LLC',
                    '    AI & Network Consulting',
                    '',
                    border,
                    '',
                    '<span class="output-success">System Status:</span>',
                    '',
                    '[AI SYSTEMS]......... <span class="output-success">ONLINE</span>',
                    '[AUTOMATION]......... <span class="output-success">ACTIVE</span>',
                    '[OPEN SOURCE]........ <span class="output-success">LIVE</span>',
                    '[CONSULTING]......... <span class="output-success">READY</span>',
                    '',
                    'contact@neuralconfig.com',
                    'github.com/neuralconfig',
                    '',
                    border
                ];
            } else {
                return [
                    border,
                    '',
                    '                              NEURALCONFIG LLC',
                    '                         AI & Network Consulting',
                    '',
                    border,
                    '',
                    '<span class="output-success">Welcome to NeuralConfig</span>',
                    '',
                    '[AI SYSTEMS]......................... <span class="output-success">OPERATIONAL</span>',
                    '[NETWORK AUTOMATION]................. <span class="output-success">ACTIVE</span>',
                    '[OPEN SOURCE TOOLS].................. <span class="output-success">ONLINE</span>',
                    '[CONSULTING SERVICES]................ <span class="output-success">AVAILABLE</span>',
                    '',
                    '        Contact: contact@neuralconfig.com',
                    '        GitHub: github.com/neuralconfig',
                    '',
                    border
                ];
            }
        }

        // Banner will be created when showSecurityBanner() is called (after DOM ready)
        let securityBanner = null;
        
        // Terminal commands and outputs
        const commands = [
            {
                prompt: 'root@neuralconfig:~#',
                command: ' whoami',
                output: [
                    '<span class="output-highlight">Network Engineer × AI Developer</span>',
                    'Bridging 20+ years of network infrastructure with modern AI systems',
                    'Building production-ready intelligent automation',
                    '',
                    'Most AI devs don\'t understand networks. Most network engineers don\'t build AI.',
                    'I do both.'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' tree -L 1 ~/projects --dirsfirst',
                output: [
                    '<span class="output-highlight">~/projects</span>',
                    '├── <span class="output-success">ruckus-ztp/</span>         # AI-powered network provisioning',
                    '├── <span class="output-success">osticket-agent/</span>     # Autonomous support agent',
                    '├── <span class="output-info">r1-api/</span>             # RUCKUS One Python SDK',
                    '├── <span class="output-info">survival-rag/</span>       # RAG knowledge system',
                    '├── <span class="output-info">device-profiler/</span>    # IoT device classification',
                    '└── <span class="output-dim">sz-acl/</span>             # ACL management tool'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: '# click or press any key to interact',
                output: []
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat services.yaml',
                output: [
                    '<span class="output-highlight">Core Services:</span>',
                    '  <span class="output-success">✓</span> AI System Architecture & Consulting',
                    '  <span class="output-success">✓</span> Network Automation & Zero-Touch Provisioning',
                    '  <span class="output-success">✓</span> Agentic AI Development',
                    '  <span class="output-success">✓</span> RAG Implementation & LLM Integration',
                    '  <span class="output-success">✓</span> Open Source Network Management Tools'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' curl -s localhost:8080/api/profile | jq \'.skills[]\'',
                output: [
                    '"Agentic AI System Architecture"',
                    '"LLM Integration (Claude, GPT, Gemini)"',
                    '"RAG & Vector Database Implementation"',
                    '"Network Automation (Python/NETCONF)"',
                    '"Zero-Touch Provisioning"',
                    '"CISSP | Zero Trust Security"'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' echo $MISSION',
                output: [
                    '<span class="output-highlight">"Building intelligent systems that solve real-world infrastructure challenges"</span>',
                    '',
                    'Network engineers: Need AI that understands your stack',
                    'AI companies: Need someone who knows production infrastructure',
                    'Enterprise: Need automation that actually works in the real world'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' git log --oneline -5',
                output: [
                    '<span class="output-warning">eba9d52</span> feat: update positioning to Principal Systems Engineer',
                    '<span class="output-warning">01977cc</span> feat: add r1-api project and enhance terminal',
                    '<span class="output-warning">e9314e9</span> feat: add ruckus-ztp and enhance AI agent emphasis',
                    '<span class="output-warning">d11c795</span> feat: add RUCKUS One Python SDK',
                    '<span class="output-warning">41e41cb</span> feat: osticket autonomous AI agent'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' systemctl status automation-stack',
                output: [
                    '<span class="output-success">●</span> automation-stack.service - Network Automation Platform',
                    '   Loaded: loaded (/etc/systemd/system/automation.service; enabled)',
                    '   Active: <span class="output-success">active (running)</span> since Jan 2025',
                    '   Status: "Processing automation workflows"',
                    '   Memory: 512.0M | CPU: 2.5%'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' docker ps --format "table {{.Names}}\\t{{.Status}}"',
                output: [
                    'NAMES                STATUS',
                    'ai-agent             Up 45 days',
                    'vector-database      Up 45 days',
                    'api-gateway          Up 45 days',
                    'monitoring           Up 45 days'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' curl https://neuralconfig.com/tools/ | jq .available',
                output: [
                    '{',
                    '  "fastiron-navigator": "live",',
                    '  "sz-acl": "maintenance"',
                    '}'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat ruckus-ztp/agent.py | head -20',
                output: [
                    '<span class="output-dim"># AI Agent for RUCKUS Zero-Touch Provisioning</span>',
                    '<span class="output-dim">from anthropic import Anthropic</span>',
                    '<span class="output-dim">import json</span>',
                    '',
                    '<span class="output-dim">def configure_device(device_info):</span>',
                    '<span class="output-dim">    """Use AI to generate optimal configuration"""</span>',
                    '<span class="output-dim">    client = Anthropic()</span>',
                    '<span class="output-dim">    response = client.messages.create(</span>',
                    '<span class="output-dim">        model="claude-3-5-sonnet-20241022",</span>',
                    '<span class="output-dim">        tools=[network_config_tool],</span>',
                    '<span class="output-dim">        messages=[{</span>',
                    '<span class="output-dim">            "role": "user",</span>',
                    '<span class="output-dim">            "content": f"Configure {device_info}"</span>',
                    '<span class="output-dim">        }]</span>',
                    '<span class="output-dim">    )</span>',
                    '',
                    '<span class="output-success">✓ Autonomous AI configuration engine</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' kubectl get pods -n production',
                output: [
                    'NAME                          READY   STATUS    RESTARTS   AGE',
                    'ai-agent-7d9f8c4b5-x9k2m      1/1     Running   0          15d',
                    'vector-db-6c8d7f9b4-p7q3n     1/1     Running   0          15d',
                    'api-gateway-5b7c8d9f2-m4r5t   1/1     Running   0          15d',
                    'rag-service-8f9d2c3b7-k6p8w   1/1     Running   0          12d',
                    '',
                    '<span class="output-success">All systems operational</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' tail -f /var/log/ai-agent/activity.log',
                output: [
                    '<span class="output-dim">2025-01-15 14:23:45</span> <span class="output-success">[INFO]</span> Processing support ticket #4521',
                    '<span class="output-dim">2025-01-15 14:23:46</span> <span class="output-success">[INFO]</span> RAG context retrieved: 15 documents',
                    '<span class="output-dim">2025-01-15 14:23:47</span> <span class="output-success">[INFO]</span> Agent decision: route to network team',
                    '<span class="output-dim">2025-01-15 14:23:48</span> <span class="output-success">[INFO]</span> Ticket categorized: L3 routing issue',
                    '<span class="output-dim">2025-01-15 14:23:49</span> <span class="output-success">[INFO]</span> Response generated and validated',
                    '',
                    '<span class="output-dim">^C</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' terraform plan -out=infrastructure.tfplan',
                output: [
                    '<span class="output-info">Terraform v1.6.0</span>',
                    '<span class="output-dim">Refreshing state... [36s elapsed]</span>',
                    '',
                    '<span class="output-success">Plan: 3 to add, 0 to change, 0 to destroy.</span>',
                    '',
                    '  + google_cloud_function.ai_agent',
                    '  + google_cloud_run.api_service',
                    '  + google_compute_instance.monitoring',
                    '',
                    '<span class="output-dim">Saved the plan to: infrastructure.tfplan</span>'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat osticket-agent/stats.json | jq .',
                output: [
                    '{',
                    '  "tickets_processed": <span class="output-success">2,847</span>,',
                    '  "avg_response_time": "<span class="output-success">45s</span>",',
                    '  "accuracy_rate": "<span class="output-success">94.3%</span>",',
                    '  "categories": {',
                    '    "network": 1203,',
                    '    "security": 892,',
                    '    "application": 752',
                    '  },',
                    '  "status": "<span class="output-success">operational</span>"',
                    '}'
                ]
            },
            {
                prompt: 'root@neuralconfig:~#',
                command: ' cat ai-safety-protocols.md',
                output: [
                    '<span class="output-highlight">AI Safety Principles:</span>',
                    '',
                    '<span class="output-success">✓</span> Human-in-the-loop for destructive actions',
                    '<span class="output-success">✓</span> Comprehensive audit logging',
                    '<span class="output-success">✓</span> Rate limiting and circuit breakers',
                    '<span class="output-success">✓</span> Graceful degradation on uncertainty',
                    '<span class="output-success">✓</span> Explicit approval workflows for production changes',
                    '',
                    '<span class="output-dim">"Reliable AI is responsible AI"</span>'
                ]
            },
        ];

        function addLine(content, className = '') {
            const line = document.createElement('div');
            line.className = 'terminal-line ' + className;
            line.innerHTML = content;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            return line;
        }

        function showSecurityBanner() {
            return new Promise((resolve) => {
                // Create banner now that terminal is ready
                if (!securityBanner) {
                    securityBanner = createBanner();
                }

                let bannerIndex = 0;

                function showNextLine() {
                    if (bannerIndex < securityBanner.length) {
                        const line = document.createElement('div');
                        line.className = 'terminal-line terminal-output banner-line';

                        // Add cursor at the end of the line while drawing
                        const textContent = securityBanner[bannerIndex];
                        line.innerHTML = textContent + '<span class="terminal-cursor"></span>';
                        terminal.appendChild(line);

                        // Remove cursor after brief pause
                        setTimeout(() => {
                            const cursor = line.querySelector('.terminal-cursor');
                            if (cursor) cursor.remove();

                            bannerIndex++;
                            // Faster display for banner lines
                            setTimeout(showNextLine, 50);
                        }, 100);
                    } else {
                        // Banner complete, add blinking cursor
                        const cursorLine = document.createElement('div');
                        cursorLine.className = 'terminal-line';
                        cursorLine.innerHTML = '<span class="terminal-cursor"></span>';
                        terminal.appendChild(cursorLine);

                        // Wait then start matrix (keep banner visible)
                        setTimeout(() => {
                            // Don't start matrix if game is active
                            if (window.gameActive) {
                                console.log('[TERMINAL] Skipping matrix start - game is active');
                                showBanner = false;
                                resolve();
                                return;
                            }

                            showBanner = false;

                            // Start matrix effect with banner still visible
                            if (typeof startMatrix === 'function') {
                                startMatrix();
                            }

                            resolve();
                        }, 2000);
                    }
                }
                
                showNextLine();
            });
        }

        // Asteroids game implementation
        function startAsteroidsGame() {
            // Set flag to prevent matrix resize during game initialization
            window.gameActive = true;

            // Disable interactive mode to prevent interference
            if (interactiveMode) {
                interactiveMode = false;
            }

            // Always pause auto mode during game to prevent key handler conflicts
            autoMode = false;

            // Remove interactive prompt if it exists
            if (currentInputLine) {
                currentInputLine.remove();
                currentInputLine = null;
            }

            let gameActive = true;
            let score = 0;
            let lives = 3;
            let level = 1;
            let invincible = false;
            let invincibleTimer = 0;
            let ship = { x: 350, y: 240, angle: 0, vx: 0, vy: 0 }; // Start at center of canvas
            let asteroids = [];
            let bullets = [];
            let gameInterval;

            // Helper function to create random asteroid shape
            function createAsteroidShape() {
                const sides = 7 + Math.floor(Math.random() * 6); // 7-12 sides
                const shape = [];
                for (let i = 0; i < sides; i++) {
                    const radiusVariation = 0.7 + Math.random() * 0.6; // 0.7 to 1.3
                    shape.push(radiusVariation);
                }
                return shape;
            }

            // ASCII version removed - game goes directly to vector graphics

            // Vector graphics upgrade
            let canvas, ctx, particles = [];
            let audioContext, sounds = {};
            let stars = [];
            let screenShake = 0;
            let heartbeatInterval = null;
            let heartbeatTempo = 800; // milliseconds between beats (starts slow)
            let initialAsteroidCount = 0; // Track starting count for tempo calculation
            let asteroidThreatLevel = 0; // Track threat level for heartbeat (decreases monotonically)
            let ufo = null; // UFO object
            let ufoSpawnTimer = 0; // Timer for UFO spawning
            let ufoSirenOscillator = null; // UFO continuous siren oscillator
            let ufoSirenGain = null; // UFO siren gain node

            function triggerUpgrade() {
                // Keep game active flag set during vector graphics game
                // (already set to true at start of startAsteroidsGame)

                clearInterval(gameInterval);

                // DON'T restart matrix - it's already running continuously
                // DON'T hide terminal yet - we'll fade it out smoothly

                // Create game container first
                const gameContainer = document.createElement('div');
                gameContainer.id = 'asteroids-container';
                gameContainer.style.position = 'fixed';
                gameContainer.style.top = '50%';
                gameContainer.style.left = '50%';
                gameContainer.style.transform = 'translate(-50%, -50%)';
                gameContainer.style.zIndex = '100';
                gameContainer.style.opacity = '0';
                gameContainer.style.transition = 'opacity 0.5s ease';
                document.body.appendChild(gameContainer);

                // Create canvas with CRT effects
                canvas = document.createElement('canvas');
                canvas.width = 700;
                canvas.height = 480;
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                canvas.style.border = '2px solid #39ff14';
                canvas.style.borderRadius = '4px';
                canvas.style.background = '#000';
                canvas.style.boxShadow = '0 0 30px rgba(57, 255, 20, 0.6), inset 0 0 60px rgba(0, 255, 0, 0.1)';
                gameContainer.appendChild(canvas);
                ctx = canvas.getContext('2d');

                // Add scanline overlay
                const scanlineCanvas = document.createElement('canvas');
                scanlineCanvas.width = 700;
                scanlineCanvas.height = 480;
                scanlineCanvas.style.position = 'absolute';
                scanlineCanvas.style.top = '0';
                scanlineCanvas.style.left = '0';
                scanlineCanvas.style.pointerEvents = 'none';
                const scanCtx = scanlineCanvas.getContext('2d');
                for (let y = 0; y < scanlineCanvas.height; y += 3) {
                    scanCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    scanCtx.fillRect(0, y, scanlineCanvas.width, 1);
                }
                gameContainer.appendChild(scanlineCanvas);

                    // NOW convert ship and asteroids for vector mode
                    ship.angle = ship.angle * (Math.PI / 2); // Convert from 0-3 to radians
                    ship.x = canvas.width / 2; // Center ship
                    ship.y = canvas.height / 2;
                    ship.vx = 0;
                    ship.vy = 0;

                    // Clear asteroids and respawn safely for vector mode
                    const oldScore = score;
                    asteroids = [];
                    bullets = [];

                    // Spawn asteroids for vector mode with safe zone
                    const asteroidCount = 3 + level;
                    for (let i = 0; i < asteroidCount; i++) {
                        const safeZone = 150;
                        let x, y;
                        do {
                            x = Math.random() * canvas.width;
                            y = Math.random() * canvas.height;
                        } while (Math.abs(x - canvas.width/2) < safeZone && Math.abs(y - canvas.height/2) < safeZone);

                        asteroids.push({
                            x, y,
                            vx: (Math.random() - 0.5) * 2.4,
                            vy: (Math.random() - 0.5) * 2.4,
                            size: 25 + Math.random() * 5,
                            shape: createAsteroidShape()
                        });
                    }
                    score = oldScore;
                    initialAsteroidCount = asteroidCount; // Set initial count for heartbeat tempo

                    // Calculate initial threat level (large asteroids = highest threat)
                    asteroidThreatLevel = asteroids.reduce((total, ast) => total + ast.size, 0);

                    // Initialize starfield
                    for (let i = 0; i < 50; i++) {
                        stars.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            brightness: Math.random()
                        });
                    }

                    // Initialize audio
                    initAudio();

                    // Add vector keyboard handlers
                    document.addEventListener('keydown', vectorKeyHandler);
                    document.addEventListener('keyup', vectorKeyHandler);

                    // Smooth transition: fade out terminal, fade in canvas
                    setTimeout(() => {
                        // Fade out terminal
                        terminal.style.transition = 'opacity 0.3s ease';
                        terminal.style.opacity = '0';

                        // Fade in vector game
                        gameContainer.style.opacity = '1';

                        // Hide terminal completely after fade
                        setTimeout(() => {
                            terminal.style.display = 'none';
                            console.log('[TERMINAL] Clearing terminal after vector graphics fade');
                            console.trace('[TERMINAL] Stack trace for terminal clear');
                            terminal.innerHTML = ''; // Clear content after it's hidden
                        }, 300);
                    }, 100);

                    // Start heartbeat background sound
                    startHeartbeat();

                    // Start vector game loop immediately
                    gameInterval = setInterval(updateVectorGame, 16); // ~60fps
            }

            function initAudio() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create sound functions
                    sounds.shoot = () => {
                        // Improved laser sound with harmonic overtones for authentic Atari "pew"
                        const now = audioContext.currentTime;

                        // Primary oscillator - sharper attack
                        const osc1 = audioContext.createOscillator();
                        const gain1 = audioContext.createGain();
                        osc1.connect(gain1);
                        gain1.connect(audioContext.destination);
                        osc1.type = 'square';
                        osc1.frequency.setValueAtTime(1400, now);
                        osc1.frequency.exponentialRampToValueAtTime(150, now + 0.06);
                        gain1.gain.setValueAtTime(0.12, now);
                        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.06);

                        // Harmonic oscillator for metallic "ping"
                        const osc2 = audioContext.createOscillator();
                        const gain2 = audioContext.createGain();
                        osc2.connect(gain2);
                        gain2.connect(audioContext.destination);
                        osc2.type = 'sine';
                        osc2.frequency.setValueAtTime(2800, now);
                        osc2.frequency.exponentialRampToValueAtTime(300, now + 0.04);
                        gain2.gain.setValueAtTime(0.08, now);
                        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.04);

                        osc1.start(now);
                        osc2.start(now);
                        osc1.stop(now + 0.06);
                        osc2.stop(now + 0.04);
                    };

                    sounds.explode = () => {
                        // Improved explosion with multi-frequency sweep and white noise burst
                        const now = audioContext.currentTime;

                        // Low frequency rumble
                        const osc1 = audioContext.createOscillator();
                        const gain1 = audioContext.createGain();
                        osc1.connect(gain1);
                        gain1.connect(audioContext.destination);
                        osc1.type = 'sawtooth';
                        osc1.frequency.setValueAtTime(250, now);
                        osc1.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                        gain1.gain.setValueAtTime(0.25, now);
                        gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                        // Mid frequency crunch
                        const osc2 = audioContext.createOscillator();
                        const gain2 = audioContext.createGain();
                        osc2.connect(gain2);
                        gain2.connect(audioContext.destination);
                        osc2.type = 'triangle';
                        osc2.frequency.setValueAtTime(450, now);
                        osc2.frequency.exponentialRampToValueAtTime(50, now + 0.25);
                        gain2.gain.setValueAtTime(0.15, now);
                        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

                        // White noise burst for "chunky" explosion
                        const bufferSize = audioContext.sampleRate * 0.3;
                        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const output = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            output[i] = Math.random() * 2 - 1;
                        }
                        const noise = audioContext.createBufferSource();
                        noise.buffer = buffer;
                        const noiseGain = audioContext.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(audioContext.destination);
                        noiseGain.gain.setValueAtTime(0.15, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                        osc1.start(now);
                        osc2.start(now);
                        noise.start(now);
                        osc1.stop(now + 0.4);
                        osc2.stop(now + 0.25);
                        noise.stop(now + 0.2);
                    };

                    sounds.thrust = () => {
                        // Create pink noise buffer for thruster
                        const bufferSize = audioContext.sampleRate * 0.15;
                        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const output = buffer.getChannelData(0);

                        // Generate pink noise (filtered white noise)
                        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                        for (let i = 0; i < bufferSize; i++) {
                            const white = Math.random() * 2 - 1;
                            b0 = 0.99886 * b0 + white * 0.0555179;
                            b1 = 0.99332 * b1 + white * 0.0750759;
                            b2 = 0.96900 * b2 + white * 0.1538520;
                            b3 = 0.86650 * b3 + white * 0.3104856;
                            b4 = 0.55000 * b4 + white * 0.5329522;
                            b5 = -0.7616 * b5 - white * 0.0168980;
                            output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                            b6 = white * 0.115926;
                        }

                        const noise = audioContext.createBufferSource();
                        noise.buffer = buffer;

                        const noiseGain = audioContext.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(audioContext.destination);

                        // Add low frequency rumble
                        const rumble = audioContext.createOscillator();
                        rumble.type = 'sawtooth';
                        rumble.frequency.value = 60;
                        const rumbleGain = audioContext.createGain();
                        rumble.connect(rumbleGain);
                        rumbleGain.connect(audioContext.destination);

                        // Envelope
                        noiseGain.gain.setValueAtTime(0.08, audioContext.currentTime);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);
                        rumbleGain.gain.setValueAtTime(0.03, audioContext.currentTime);
                        rumbleGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.12);

                        noise.start();
                        rumble.start();
                        noise.stop(audioContext.currentTime + 0.15);
                        rumble.stop(audioContext.currentTime + 0.15);
                    };

                    // Heartbeat/Jaws sound - iconic Atari Asteroids background pulse
                    sounds.heartbeat = (beatNumber) => {
                        const now = audioContext.currentTime;
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.type = 'sine';

                        // Alternate between two frequencies for "heartbeat" effect
                        const freq = beatNumber % 2 === 0 ? 100 : 80;
                        osc.frequency.setValueAtTime(freq, now);

                        // Short, punchy envelope
                        gain.gain.setValueAtTime(0.25, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                        osc.start(now);
                        osc.stop(now + 0.08);
                    };

                    // UFO continuous siren - creates a sweeping frequency oscillator
                    sounds.startUfoSiren = () => {
                        if (ufoSirenOscillator) return; // Already running

                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.type = 'square';

                        // Set up continuous frequency sweep (siren effect)
                        const minFreq = 800; // Higher pitched
                        const maxFreq = 1200;
                        const sweepDuration = 0.5; // Half second per sweep

                        const now = audioContext.currentTime;
                        osc.frequency.setValueAtTime(minFreq, now);

                        // Create continuous sweep up and down
                        let time = now;
                        for (let i = 0; i < 100; i++) { // 50 seconds worth of sweeps
                            osc.frequency.linearRampToValueAtTime(maxFreq, time + sweepDuration);
                            time += sweepDuration;
                            osc.frequency.linearRampToValueAtTime(minFreq, time + sweepDuration);
                            time += sweepDuration;
                        }

                        gain.gain.setValueAtTime(0.08, now);

                        osc.start(now);
                        ufoSirenOscillator = osc;
                        ufoSirenGain = gain;
                    };

                    sounds.stopUfoSiren = () => {
                        if (ufoSirenOscillator) {
                            const now = audioContext.currentTime;
                            ufoSirenGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                            ufoSirenOscillator.stop(now + 0.1);
                            ufoSirenOscillator = null;
                            ufoSirenGain = null;
                        }
                    };

                    // UFO shoot sound
                    sounds.ufoShoot = () => {
                        const now = audioContext.currentTime;
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.type = 'sawtooth';

                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);

                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                        osc.start(now);
                        osc.stop(now + 0.15);
                    };
                } catch (e) {
                    console.log('Audio not supported');
                    sounds = { shoot: ()=>{}, explode: ()=>{}, thrust: ()=>{}, heartbeat: ()=>{}, startUfoSiren: ()=>{}, stopUfoSiren: ()=>{}, ufoShoot: ()=>{} };
                }
            }

            function createParticles(x, y, count = 10) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        life: 1.0
                    });
                }
            }

            function startHeartbeat() {
                if (heartbeatInterval) return; // Already running

                let beatCount = 0;
                const initialThreat = asteroidThreatLevel; // Capture initial threat level

                function playBeat() {
                    if (sounds.heartbeat && gameActive) {
                        sounds.heartbeat(beatCount);
                        beatCount++;

                        // Calculate tempo based on threat level (lower threat = faster tempo)
                        const baseRate = 800; // Starting tempo (slow)
                        const minRate = 200;  // Fastest tempo

                        // Calculate current threat level
                        const currentThreat = asteroids.reduce((total, ast) => total + ast.size, 0);

                        // Progress from 0 (start) to 1 (all asteroids destroyed)
                        const progress = initialThreat > 0 ?
                            1 - (currentThreat / initialThreat) : 0;

                        // Starts at 800ms (slow), accelerates to 200ms (fast) as asteroids destroyed
                        heartbeatTempo = Math.max(minRate, baseRate - (progress * (baseRate - minRate)));

                        heartbeatInterval = setTimeout(playBeat, heartbeatTempo);
                    }
                }
                playBeat();
            }

            function stopHeartbeat() {
                if (heartbeatInterval) {
                    clearTimeout(heartbeatInterval);
                    heartbeatInterval = null;
                }
            }

            // UFO functions
            function startUfoSiren() {
                if (!ufo || ufoSirenOscillator) return;
                if (sounds.startUfoSiren) {
                    sounds.startUfoSiren();
                }
            }

            function stopUfoSiren() {
                if (sounds.stopUfoSiren) {
                    sounds.stopUfoSiren();
                }
            }

            function spawnUFO() {
                if (ufo) return; // UFO already active

                // Determine UFO size based on score (small UFO at higher scores)
                const isSmall = score > 10000;
                const size = isSmall ? 15 : 25; // Made smaller: was 20/35
                const speed = isSmall ? 3 : 1.5;

                // Spawn from left or right edge
                const fromLeft = Math.random() > 0.5;
                const x = fromLeft ? -size : canvas.width + size;
                const y = Math.random() * (canvas.height * 0.6) + (canvas.height * 0.2); // Middle 60% of screen

                ufo = {
                    x, y,
                    size,
                    vx: fromLeft ? speed : -speed,
                    isSmall,
                    shootTimer: Math.random() * 2 + 1 // Shoot every 1-3 seconds
                };

                startUfoSiren();
            }

            function updateUFO(deltaTime = 0.016) {
                if (!ufo) return;

                // Move UFO
                ufo.x += ufo.vx;

                // UFO shoots at player occasionally
                ufo.shootTimer -= deltaTime;
                if (ufo.shootTimer <= 0) {
                    ufo.shootTimer = Math.random() * 2 + 1;

                    // Shoot in player's general direction (with some inaccuracy)
                    const dx = ship.x - ufo.x;
                    const dy = ship.y - ufo.y;
                    const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.5; // Add inaccuracy

                    bullets.push({
                        x: ufo.x,
                        y: ufo.y,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        fromUFO: true
                    });

                    if (sounds.ufoShoot) sounds.ufoShoot();
                }

                // Remove UFO if it goes off screen
                if ((ufo.vx > 0 && ufo.x > canvas.width + ufo.size) ||
                    (ufo.vx < 0 && ufo.x < -ufo.size)) {
                    ufo = null;
                    stopUfoSiren();
                }
            }

            function renderUFO() {
                if (!ufo) return;

                ctx.save();
                ctx.translate(ufo.x, ufo.y);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;

                // Draw classic UFO shape
                ctx.beginPath();

                // Top dome
                ctx.arc(0, -ufo.size * 0.3, ufo.size * 0.4, 0, Math.PI, true);

                // Main body
                ctx.moveTo(-ufo.size, 0);
                ctx.lineTo(-ufo.size * 0.7, ufo.size * 0.3);
                ctx.lineTo(ufo.size * 0.7, ufo.size * 0.3);
                ctx.lineTo(ufo.size, 0);
                ctx.lineTo(-ufo.size, 0);

                // Bottom section
                ctx.moveTo(-ufo.size * 0.5, ufo.size * 0.3);
                ctx.lineTo(-ufo.size * 0.3, ufo.size * 0.5);
                ctx.lineTo(ufo.size * 0.3, ufo.size * 0.5);
                ctx.lineTo(ufo.size * 0.5, ufo.size * 0.3);

                ctx.stroke();

                // Add some detail windows
                ctx.fillStyle = '#00ff00';
                for (let i = -1; i <= 1; i++) {
                    ctx.fillRect(i * ufo.size * 0.3 - 2, -ufo.size * 0.25, 4, 4);
                }

                ctx.restore();
            }

            function renderVectorGame() {
                // Apply screen shake
                ctx.save();
                if (screenShake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * screenShake,
                        (Math.random() - 0.5) * screenShake
                    );
                    screenShake *= 0.9;
                }

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw starfield
                stars.forEach(star => {
                    star.brightness += (Math.random() - 0.5) * 0.1;
                    star.brightness = Math.max(0.3, Math.min(1, star.brightness));
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * 0.6})`;
                    ctx.fillRect(star.x, star.y, 1, 1);
                });

                // Draw particles with glow
                particles.forEach(p => {
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = `rgba(0, 255, 0, ${p.life})`;
                    ctx.fillStyle = `rgba(0, 255, 0, ${p.life})`;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                });
                ctx.shadowBlur = 0;

                // Draw asteroids with random shapes and phosphor glow
                asteroids.forEach(ast => {
                    // Phosphor glow effect
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const sides = ast.shape ? ast.shape.length : 8;
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const radiusVar = ast.shape ? ast.shape[i] : 1;
                        const radius = ast.size * radiusVar;
                        const x = ast.x + Math.cos(angle) * radius;
                        const y = ast.y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                });

                // Draw bullets with phosphor glow
                bullets.forEach(b => {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00ff00';
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });

                // Draw UFO
                renderUFO();

                // Draw ship (with invincibility flash and phosphor glow)
                if (!invincible || Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.save();
                    ctx.translate(ship.x, ship.y);
                    ctx.rotate(ship.angle);
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(-10, 10);
                    ctx.lineTo(0, 5);
                    ctx.lineTo(10, 10);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Thrust flame with glow
                    if (keys.ArrowUp) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff6600';
                        ctx.fillStyle = '#ff6600';
                        ctx.beginPath();
                        ctx.moveTo(-5, 10);
                        ctx.lineTo(0, 20 + Math.random() * 5);
                        ctx.lineTo(5, 10);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    ctx.restore();
                }

                // Draw lives with glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ff00';
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                for (let i = 0; i < lives - 1; i++) {
                    ctx.save();
                    ctx.translate(30 + i * 25, canvas.height - 30);
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(-6, 6);
                    ctx.lineTo(0, 3);
                    ctx.lineTo(6, 6);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.shadowBlur = 0;

                ctx.restore(); // Restore from screen shake

                // Score and Level with phosphor glow
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#00ff00';
                ctx.fillStyle = '#00ff00';
                ctx.font = '20px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('SCORE: ' + score, 30, 30);
                ctx.fillText('LEVEL: ' + level, 30, 55);
                ctx.fillText('H: HYPERSPACE', canvas.width - 180, 30);
                ctx.fillText('Q: QUIT', canvas.width - 100, 55);
                ctx.shadowBlur = 0;

                if (!gameActive) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff5f56';
                    ctx.font = '48px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.font = '24px monospace';
                    ctx.fillStyle = '#39ff14';
                    ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
                }
            }

            let keys = {};
            function vectorKeyHandler(e) {
                keys[e.key] = e.type === 'keydown';

                // Hyperspace
                if ((e.key === 'h' || e.key === 'H') && e.type === 'keydown' && !keys.hyperUsed) {
                    keys.hyperUsed = true;
                    createParticles(ship.x, ship.y, 10);
                    ship.x = Math.random() * canvas.width;
                    ship.y = Math.random() * canvas.height;
                    ship.vx = 0;
                    ship.vy = 0;
                    createParticles(ship.x, ship.y, 10);

                    // 10% chance of destruction
                    if (Math.random() < 0.1) {
                        lives--;
                        if (lives > 0) {
                            respawnShip();
                        } else {
                            gameActive = false;
                            clearInterval(gameInterval);
                            stopHeartbeat(); // Stop background heartbeat on hyperspace death
                        }
                    }
                    setTimeout(() => keys.hyperUsed = false, 500);
                }

                if (e.key === 'q' || e.key === 'Q') {
                    gameActive = false;
                    clearInterval(gameInterval);
                    stopHeartbeat(); // Stop background heartbeat sound
                    stopUfoSiren(); // Stop UFO sound
                    document.removeEventListener('keydown', vectorKeyHandler);
                    document.removeEventListener('keyup', vectorKeyHandler);

                    // Clean up game container
                    const gameContainer = document.getElementById('asteroids-container');
                    if (gameContainer) gameContainer.remove();

                    // Show terminal and return to auto mode
                    terminal.style.display = 'block';
                    terminal.style.opacity = '1'; // Restore full opacity
                    terminal.innerHTML = '';
                    setTimeout(() => {
                        returnToAutoMode();
                    }, 100);
                }
                e.preventDefault();
            }

            function respawnShip() {
                ship.x = canvas.width / 2;
                ship.y = canvas.height / 2;
                ship.vx = 0;
                ship.vy = 0;
                ship.angle = 0;
                invincible = true;
                invincibleTimer = 2500; // 2.5 seconds
            }

            function updateVectorGame() {
                if (!gameActive) {
                    renderVectorGame();
                    return;
                }

                // Update invincibility
                if (invincible) {
                    invincibleTimer -= 16;
                    if (invincibleTimer <= 0) {
                        invincible = false;
                    }
                }

                // Ship controls - smooth 360° rotation
                if (keys.ArrowLeft) ship.angle -= 0.1;
                if (keys.ArrowRight) ship.angle += 0.1;
                if (keys.ArrowUp) {
                    ship.vx += Math.sin(ship.angle) * 0.3;
                    ship.vy -= Math.cos(ship.angle) * 0.3;
                    if (sounds.thrust && Math.random() > 0.7) sounds.thrust();
                }
                if (keys[' '] && !keys.spaceFired) {
                    keys.spaceFired = true;
                    bullets.push({
                        x: ship.x + Math.sin(ship.angle) * 15,
                        y: ship.y - Math.cos(ship.angle) * 15,
                        vx: Math.sin(ship.angle) * 8,
                        vy: -Math.cos(ship.angle) * 8
                    });
                    if (sounds.shoot) sounds.shoot();
                }
                if (!keys[' ']) keys.spaceFired = false;

                // Update physics
                ship.x += ship.vx;
                ship.y += ship.vy;
                ship.vx *= 0.98;
                ship.vy *= 0.98;

                // Wrap
                if (ship.x < 0) ship.x = canvas.width;
                if (ship.x > canvas.width) ship.x = 0;
                if (ship.y < 0) ship.y = canvas.height;
                if (ship.y > canvas.height) ship.y = 0;

                // Update asteroids
                asteroids.forEach(ast => {
                    ast.x += ast.vx;
                    ast.y += ast.vy;
                    if (ast.x < 0) ast.x = canvas.width;
                    if (ast.x > canvas.width) ast.x = 0;
                    if (ast.y < 0) ast.y = canvas.height;
                    if (ast.y > canvas.height) ast.y = 0;
                });

                // Update bullets
                bullets = bullets.filter(b => {
                    b.x += b.vx;
                    b.y += b.vy;
                    return b.x >= 0 && b.x <= canvas.width && b.y >= 0 && b.y <= canvas.height;
                });

                // Update particles
                particles = particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    return p.life > 0;
                });

                // Update UFO
                updateUFO();

                // UFO spawning timer (spawn every 15-25 seconds, starting from level 1 for testing)
                ufoSpawnTimer += 0.016; // ~16ms per frame
                if (!ufo && ufoSpawnTimer > (15 + Math.random() * 10)) {
                    spawnUFO();
                    ufoSpawnTimer = 0;
                }

                // Collisions
                bullets.forEach((b, bi) => {
                    asteroids.forEach((ast, ai) => {
                        const dx = b.x - ast.x;
                        const dy = b.y - ast.y;
                        if (dx*dx + dy*dy < ast.size * ast.size) {
                            bullets.splice(bi, 1);
                            const oldSize = ast.size;
                            asteroids.splice(ai, 1);
                            score += Math.floor((30 - oldSize) * 2);
                            createParticles(ast.x, ast.y, 15);
                            screenShake = 5;
                            if (sounds.explode) sounds.explode();

                            // Check for extra life at 10,000 points
                            if (score >= 10000 && score - Math.floor((30 - oldSize) * 2) < 10000) {
                                lives++;
                            }

                            if (oldSize > 10) {
                                for (let i = 0; i < 2; i++) {
                                    asteroids.push({
                                        x: ast.x,
                                        y: ast.y,
                                        vx: (Math.random() - 0.5) * 3,
                                        vy: (Math.random() - 0.5) * 3,
                                        size: oldSize / 2,
                                        shape: createAsteroidShape()
                                    });
                                }
                            }
                        }
                    });
                });

                // UFO collision detection
                if (ufo) {
                    // Player bullets hitting UFO
                    for (let i = bullets.length - 1; i >= 0; i--) {
                        const b = bullets[i];
                        if (b.fromUFO) continue; // Skip UFO's own bullets

                        const dx = b.x - ufo.x;
                        const dy = b.y - ufo.y;
                        if (dx*dx + dy*dy < ufo.size * ufo.size) {
                            bullets.splice(i, 1);

                            // Award points based on distance (closer = more points)
                            const distance = Math.sqrt((ship.x - ufo.x)**2 + (ship.y - ufo.y)**2);
                            const maxDistance = Math.sqrt(canvas.width**2 + canvas.height**2);
                            const pointsBase = ufo.isSmall ? 1000 : 200;
                            const bonusPoints = Math.floor(pointsBase * (1 - distance / maxDistance) * 2);
                            score += pointsBase + bonusPoints;

                            createParticles(ufo.x, ufo.y, 25);
                            screenShake = 8;
                            if (sounds.explode) sounds.explode();

                            ufo = null;
                            stopUfoSiren();
                            break;
                        }
                    }

                    // UFO hitting ship directly
                    if (ufo && !invincible) {
                        const dx = ship.x - ufo.x;
                        const dy = ship.y - ufo.y;
                        if (dx*dx + dy*dy < (ufo.size + 12) * (ufo.size + 12)) {
                            lives--;
                            createParticles(ship.x, ship.y, 30);
                            screenShake = 10;
                            if (sounds.explode) sounds.explode();

                            ufo = null;
                            stopUfoSiren();

                            if (lives > 0) {
                                respawnShip();
                            } else {
                                gameActive = false;
                                clearInterval(gameInterval);
                                stopHeartbeat();
                            }
                        }
                    }
                }

                // UFO bullets hitting ship
                if (!invincible) {
                    for (let i = bullets.length - 1; i >= 0; i--) {
                        const b = bullets[i];
                        if (!b.fromUFO) continue; // Only check UFO bullets

                        const dx = ship.x - b.x;
                        const dy = ship.y - b.y;
                        if (dx*dx + dy*dy < 144) { // 12px radius
                            bullets.splice(i, 1);
                            lives--;
                            createParticles(ship.x, ship.y, 30);
                            screenShake = 10;
                            if (sounds.explode) sounds.explode();

                            if (lives > 0) {
                                respawnShip();
                            } else {
                                gameActive = false;
                                clearInterval(gameInterval);
                                stopHeartbeat();
                            }
                            break;
                        }
                    }
                }

                // Ship collision with asteroids (with invincibility check)
                if (!invincible) {
                    asteroids.forEach(ast => {
                        const dx = ship.x - ast.x;
                        const dy = ship.y - ast.y;
                        // More forgiving hitbox (85% of normal)
                        if (dx*dx + dy*dy < (ast.size + 8) * (ast.size + 8)) {
                            lives--;
                            createParticles(ship.x, ship.y, 30);
                            screenShake = 10;
                            if (sounds.explode) sounds.explode();

                            if (lives > 0) {
                                respawnShip();
                            } else {
                                gameActive = false;
                                clearInterval(gameInterval);
                                stopHeartbeat(); // Stop background heartbeat on game over
                            }
                        }
                    });
                }

                // Level progression - check if all asteroids cleared
                if (asteroids.length === 0) {
                    level++;
                    score += 1000 * level;
                    const newAsteroidCount = Math.min(4 + (level - 1) * 2, 10);

                    // Show level message
                    clearInterval(gameInterval);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '36px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(`LEVEL ${level}`, canvas.width / 2, canvas.height / 2);

                    setTimeout(() => {
                        // Spawn new asteroids for next level
                        for (let i = 0; i < newAsteroidCount; i++) {
                            const safeZone = 150;
                            let x, y;
                            do {
                                x = Math.random() * canvas.width;
                                y = Math.random() * canvas.height;
                            } while (Math.abs(x - canvas.width/2) < safeZone && Math.abs(y - canvas.height/2) < safeZone);

                            asteroids.push({
                                x, y,
                                vx: (Math.random() - 0.5) * 2.4, // Slower for retro players
                                vy: (Math.random() - 0.5) * 2.4,
                                size: 25 + Math.random() * 5, // Large asteroids
                                shape: createAsteroidShape()
                            });
                        }
                        // Reset initial count and threat level for new level tempo calculation
                        initialAsteroidCount = newAsteroidCount;
                        asteroidThreatLevel = asteroids.reduce((total, ast) => total + ast.size, 0);
                        gameInterval = setInterval(updateVectorGame, 16);
                    }, 2000);
                }

                renderVectorGame();
            }

            // Launch vector graphics game directly
            triggerUpgrade();
        }

        // Command processor for interactive mode
        function processCommand(cmd) {
            const command = cmd.toLowerCase().trim();

            switch(command) {
                case 'help':
                    return [
                        '<span class="output-highlight">Available Commands:</span>',
                        '',
                        '<span class="output-success">Information:</span>',
                        '  help                    - Show this help message',
                        '  whoami                  - Show user information',
                        '  contact                 - Contact information',
                        '',
                        '<span class="output-success">Projects & Skills:</span>',
                        '  projects [--filter ai|network] - List projects',
                        '  skills                  - Show technical skills',
                        '',
                        '<span class="output-success">AI:</span>',
                        '  llm                     - LLM & AI model experience',
                        '  agents                  - Agentic AI systems',
                        '',
                        '<span class="output-success">Games:</span>',
                        '  asteroids               - Play Asteroids',
                        '',
                        '<span class="output-success">System:</span>',
                        '  clear                   - Clear terminal screen',
                        '  date                    - Show current date and time',
                        '  auto                    - Resume automatic demo'
                    ];

                case 'clear':
                    terminal.innerHTML = '';
                    return null;

                case 'projects':
                case 'projects --filter ai':
                case 'projects --filter network':
                    let filter = null;
                    if (cmd.includes('--filter')) {
                        const parts = cmd.split('--filter');
                        if (parts.length > 1) {
                            filter = parts[1].trim().toLowerCase();
                        }
                    }

                    const allProjects = {
                        ai: [
                            '✓ <span class="output-success">ruckus-ztp</span>        [AI-AGENT] [ACTIVE]',
                            '✓ <span class="output-success">osticket-agent</span>   [AI-AGENT] [DEPLOYED]',
                            '✓ <span class="output-success">survival-rag</span>     [AI-RAG] [ACTIVE]'
                        ],
                        network: [
                            '✓ <span class="output-info">r1-api</span>           [SDK] [LIVE]',
                            '✓ <span class="output-info">sz-acl</span>           [NETWORK] [MAINTENANCE]',
                            '✓ <span class="output-success">pflogs</span>          [SECURITY] [ACTIVE]',
                            '✓ <span class="output-info">wifi-test</span>       [NETWORK] [ACTIVE]'
                        ]
                    };

                    let output = [];

                    if (filter === 'ai') {
                        output = ['<span class="output-highlight">AI Projects:</span>', ...allProjects.ai];
                    } else if (filter === 'network') {
                        output = ['<span class="output-highlight">Network Projects:</span>', ...allProjects.network];
                    } else {
                        output = [
                            '<span class="output-highlight">Active Projects:</span>',
                            ...allProjects.ai,
                            ...allProjects.network
                        ];
                    }

                    output.push('');
                    output.push('Use --filter [ai|network] to filter projects.');
                    output.push('Visit /projects.html for detailed information.');

                    return output;

                case 'skills':
                    return [
                        '<span class="output-highlight">Core Skills:</span>',
                        '• Agentic AI System Architecture',
                        '• Large Language Model Integration',
                        '• Network Automation & Zero-Touch Provisioning',
                        '• Swift/iOS Development (ARKit, HealthKit)',
                        '• Cybersecurity (CISSP)',
                        '• Python/JavaScript Development',
                        '',
                        'Visit /skills.html for complete details.'
                    ];

                case 'llm':
                    return [
                        '<span class="output-highlight">LLM & AI Model Experience:</span>',
                        '',
                        '<span class="output-success">Commercial APIs:</span>',
                        '  • Anthropic Claude',
                        '  • OpenAI',
                        '',
                        '<span class="output-success">Open Source Models:</span>',
                        '  • Qwen (Alibaba)',
                        '  • Llama (Meta)',
                        '  • Mistral',
                        '  • DeepSeek',
                        '',
                        '<span class="output-dim">Local inference, API integration, model selection strategies</span>'
                    ];

                case 'agents':
                    return [
                        '<span class="output-highlight">Agentic AI Systems:</span>',
                        '',
                        '<span class="output-success">Architecture:</span>',
                        '  • Autonomous agent orchestration',
                        '  • Tool-calling & function execution',
                        '  • RAG systems with vector databases',
                        '',
                        '<span class="output-success">Safety Principles:</span>',
                        '  • Human-in-the-loop for destructive actions',
                        '  • Comprehensive audit logging',
                        '  • Graceful degradation on uncertainty',
                        '',
                        '<span class="output-success">Production Deployments:</span>',
                        '  • osticket-agent - Autonomous support triage',
                        '  • ruckus-ztp - AI-powered network provisioning'
                    ];

                case 'contact':
                    return [
                        '<span class="output-highlight">NeuralConfig LLC</span>',
                        'Email: contact@neuralconfig.com',
                        'Web: neuralconfig.com',
                        'GitHub: github.com/neuralconfig'
                    ];

                case 'whoami':
                    return [
                        '<span class="output-highlight">AI & Infrastructure Architect</span>',
                        'Specializing in AI-driven network automation',
                        '20+ years network infrastructure experience',
                        'Building intelligent systems at the intersection of AI and networking'
                    ];

                case 'date':
                    const now = new Date();
                    return [now.toString()];

                case 'asteroids':
                    startAsteroidsGame();
                    return null;

                case 'auto':
                    // Note: This case is normally handled in executeInteractiveCommand
                    // but included here as a fallback
                    returnToAutoMode();
                    return null;

                case '':
                    return null;

                default:
                    return [`<span class="output-error">Command not found: ${cmd}</span>`, 'Type "help" for available commands.'];
            }
        }

        function typeCommand(prompt, command, callback) {
            if (isTyping || !autoMode || interactiveMode) return;
            isTyping = true;
            
            // Add prompt immediately
            const line = addLine('');
            line.innerHTML = `<span class="terminal-prompt">${prompt}</span><span class="terminal-command"></span><span class="terminal-cursor"></span>`;
            
            const commandSpan = line.querySelector('.terminal-command');
            const cursorSpan = line.querySelector('.terminal-cursor');
            let index = 0;
            
            function typeChar() {
                // Stop if we switched modes
                if (!autoMode || interactiveMode) {
                    if (cursorSpan) cursorSpan.remove();
                    isTyping = false;
                    return;
                }
                
                if (index < command.length) {
                    commandSpan.textContent += command[index];
                    index++;
                    
                    // Variable typing speed for more realistic effect
                    const baseDelay = 40;
                    const variation = Math.random() * 60;
                    const pauseChance = Math.random();
                    let delay = baseDelay + variation;
                    
                    // Occasionally add longer pauses (thinking)
                    if (pauseChance > 0.95) {
                        delay += 200 + Math.random() * 300;
                    }
                    
                    const typeTimeoutId = setTimeout(typeChar, delay);
                    autoTimeouts.push(typeTimeoutId);
                } else {
                    // Remove cursor when done
                    if (cursorSpan) cursorSpan.remove();
                    isTyping = false;
                    if (callback && autoMode && !interactiveMode) callback();
                }
            }
            
            // Start typing after a small delay
            const startTimeoutId = setTimeout(typeChar, 200);
            autoTimeouts.push(startTimeoutId);
        }

        // Interactive mode functions
        function createInteractivePrompt() {
            if (currentInputLine) return; // Already have an active prompt

            currentInputLine = addLine('');
            currentInputLine.innerHTML = '<span class="terminal-prompt">root@neuralconfig:~#</span><span class="terminal-input"></span><span class="terminal-cursor"></span>';
            currentInputLine.classList.add('interactive-line');
        }

        function updateInputDisplay() {
            if (!currentInputLine) return;
            
            const inputSpan = currentInputLine.querySelector('.terminal-input');
            if (inputSpan) {
                inputSpan.textContent = currentInput;
            }
        }

        function executeInteractiveCommand() {
            // Guard against null currentInputLine (race condition during mode switch)
            if (!currentInputLine) return;

            // Remove cursor from current line
            const cursor = currentInputLine.querySelector('.terminal-cursor');
            if (cursor) cursor.remove();
            
            if (!currentInput.trim()) {
                // For empty input, just create a new prompt
                currentInput = '';
                currentInputLine = null;
                setTimeout(createInteractivePrompt, 100);
                return;
            }
            
            // Add command to history
            commandHistory.push(currentInput);
            historyIndex = commandHistory.length;
            
            // Special handling for 'auto' command
            if (currentInput.toLowerCase().trim() === 'auto') {
                currentInput = '';
                currentInputLine = null;
                returnToAutoMode();
                return;
            }
            
            // Process the command
            const output = processCommand(currentInput);
            
            if (output) {
                output.forEach(line => {
                    addLine(line, 'terminal-output');
                });
            }
            
            // Clear input and create new prompt if still in interactive mode
            currentInput = '';
            currentInputLine = null;
            
            if (interactiveMode) {
                setTimeout(createInteractivePrompt, 100);
            }
        }

        function resetInteractiveTimeout() {
            // Clear existing timeouts
            if (interactiveTimeout) {
                clearTimeout(interactiveTimeout);
            }
            if (window.interactiveWarningTimeout) {
                clearTimeout(window.interactiveWarningTimeout);
            }

            // Set warning at 55 seconds (5 seconds before timeout)
            window.interactiveWarningTimeout = setTimeout(() => {
                if (interactiveMode) {
                    addLine('<span class="output-warning">timeout warning: auto-logout in 5 seconds due to inactivity</span>', 'terminal-output');
                    if (currentInputLine) {
                        // Re-add the prompt after warning
                        currentInputLine.remove();
                        currentInputLine = null;
                        setTimeout(() => {
                            if (interactiveMode) createInteractivePrompt();
                        }, 50);
                    }
                }
            }, 55000);

            // Set 60-second timeout
            interactiveTimeout = setTimeout(() => {
                if (interactiveMode) {
                    addLine('<span class="output-error">auto-logout: timed out waiting for input</span>', 'terminal-output');
                    setTimeout(() => {
                        returnToAutoMode();
                    }, 1000);
                }
            }, 60000);
        }

        function returnToAutoMode() {
            interactiveMode = false;
            autoMode = true;
            currentInput = '';
            currentInputLine = null;

            // Clear interactive timeouts
            if (interactiveTimeout) {
                clearTimeout(interactiveTimeout);
                interactiveTimeout = null;
            }
            if (window.interactiveWarningTimeout) {
                clearTimeout(window.interactiveWarningTimeout);
                window.interactiveWarningTimeout = null;
            }
            
            // Resume auto demo
            setTimeout(() => {
                if (autoMode && !interactiveMode) {
                    showCommand();
                }
            }, 500);
        }

        function switchToInteractive() {
            if (interactiveMode) return;
            
            // Stop auto mode immediately
            autoMode = false;
            interactiveMode = true;
            isTyping = false;
            
            // Cancel all pending auto timeouts
            autoTimeouts.forEach(id => clearTimeout(id));
            autoTimeouts = [];
            
            // Remove any existing cursors
            const existingCursors = terminal.querySelectorAll('.terminal-cursor');
            existingCursors.forEach(cursor => cursor.remove());
            
            // Start interactive timeout
            resetInteractiveTimeout();
            
            // Add a message about switching to interactive mode
            addLine('<span class="output-success">Interactive mode activated. Type "help" for commands or "auto" to resume demo.</span>', 'terminal-output');
            
            setTimeout(createInteractivePrompt, 500);
        }

        function showNextCommandWithPrompt() {
            if (!autoMode || interactiveMode || commandIndex >= commands.length) return;

            const cmd = commands[commandIndex];
            const promptLine = addLine('');
            promptLine.innerHTML = `<span class="terminal-prompt">${cmd.prompt}</span><span class="terminal-command"></span><span class="terminal-cursor"></span>`;

            // Pause with cursor visible, then type the command
            const pauseTimeoutId = setTimeout(() => {
                if (!autoMode || interactiveMode) return;

                // Type the command character by character
                const commandSpan = promptLine.querySelector('.terminal-command');
                const cursorSpan = promptLine.querySelector('.terminal-cursor');
                let charIndex = 0;

                function typeNextChar() {
                    if (!autoMode || interactiveMode) {
                        if (cursorSpan) cursorSpan.remove();
                        return;
                    }

                    if (charIndex < cmd.command.length) {
                        commandSpan.textContent += cmd.command[charIndex];
                        charIndex++;
                        const charTimeoutId = setTimeout(typeNextChar, 40 + Math.random() * 60);
                        autoTimeouts.push(charTimeoutId);
                    } else {
                        // Command finished typing, remove cursor and show output
                        if (cursorSpan) cursorSpan.remove();

                        // Show output
                        cmd.output.forEach((line, index) => {
                            const outputTimeoutId = setTimeout(() => {
                                if (autoMode && !interactiveMode) {
                                    addLine(line, 'terminal-output');
                                }
                            }, index * outputDelay);
                            autoTimeouts.push(outputTimeoutId);
                        });

                        // Continue to next command
                        const continueTimeoutId = setTimeout(() => {
                            if (!autoMode || interactiveMode) return;
                            commandIndex++;

                            if (commandIndex < commands.length) {
                                // Show next prompt immediately and repeat
                                showNextCommandWithPrompt();
                            } else {
                                // Restart from beginning
                                const restartTimeoutId = setTimeout(() => {
                                    console.log('[AUTO-DEMO] Restart timeout fired - autoMode:', autoMode, 'interactiveMode:', interactiveMode);
                                    if (autoMode && !interactiveMode) {
                                        console.log('[AUTO-DEMO] Restarting demo from beginning (location 1)');
                                        commandIndex = 0;
                                        showCommand();
                                    } else {
                                        console.log('[AUTO-DEMO] Skipping demo restart - conditions not met');
                                    }
                                }, commandDelay);
                                autoTimeouts.push(restartTimeoutId);
                            }
                        }, cmd.output.length * outputDelay + 200);
                        autoTimeouts.push(continueTimeoutId);
                    }
                }

                typeNextChar();
            }, commandDelay);
            autoTimeouts.push(pauseTimeoutId);
        }

        function showCommand() {
            // Stop if we're not in auto mode
            if (!autoMode || interactiveMode) {
                return;
            }
            
            if (commandIndex >= commands.length) {
                // Restart demo from beginning
                const timeoutId = setTimeout(() => {
                    console.log('[AUTO-DEMO] End-of-demo timeout fired - autoMode:', autoMode, 'interactiveMode:', interactiveMode);
                    if (autoMode && !interactiveMode) {
                        console.log('[AUTO-DEMO] Restarting demo from beginning (location 2)');
                        commandIndex = 0;
                        showCommand();
                    } else {
                        console.log('[AUTO-DEMO] Skipping demo restart - conditions not met');
                    }
                }, commandDelay);
                autoTimeouts.push(timeoutId);
                return;
            }

            const cmd = commands[commandIndex];
            
            // Type the command with prompt appearing immediately
            typeCommand(cmd.prompt, cmd.command, () => {
                if (!autoMode || interactiveMode) return; // Check again after typing
                
                // Show output immediately after command is typed (no delay)
                cmd.output.forEach((line, index) => {
                    const timeoutId = setTimeout(() => {
                        if (autoMode && !interactiveMode) {
                            addLine(line, 'terminal-output');
                        }
                    }, index * outputDelay);
                    autoTimeouts.push(timeoutId);
                });
                
                // After all output is shown, show next prompt immediately
                const timeoutId = setTimeout(() => {
                    if (!autoMode || interactiveMode) return;

                    commandIndex++;

                    if (commandIndex < commands.length) {
                        // Use the new function to show prompt immediately and continue
                        showNextCommandWithPrompt();
                    } else {
                        // Restart from beginning
                        const restartTimeoutId = setTimeout(() => {
                            console.log('[AUTO-DEMO] Final restart timeout fired - autoMode:', autoMode, 'interactiveMode:', interactiveMode);
                            if (autoMode && !interactiveMode) {
                                console.log('[AUTO-DEMO] Restarting demo from beginning (location 3)');
                                commandIndex = 0;
                                showCommand();
                            } else {
                                console.log('[AUTO-DEMO] Skipping demo restart - conditions not met');
                            }
                        }, commandDelay);
                        autoTimeouts.push(restartTimeoutId);
                    }
                }, cmd.output.length * outputDelay + 200); // Small buffer after output
                autoTimeouts.push(timeoutId);
            });
        }

        // Keep only last N lines to prevent memory issues
        function limitTerminalHistory() {
            const maxLines = 30;
            while (terminal.children.length > maxLines) {
                terminal.removeChild(terminal.firstChild);
            }
        }

        // Keyboard and interaction event handlers
        document.addEventListener('keydown', function(e) {
            if (!interactiveMode && autoMode) {
                // Switch to interactive mode on any key press
                e.preventDefault();
                switchToInteractive();
                return;
            }
            
            if (!interactiveMode) return;
            
            // Reset timeout on ANY keypress in interactive mode
            resetInteractiveTimeout();
            
            switch(e.key) {
                case 'Enter':
                    e.preventDefault();
                    executeInteractiveCommand();
                    break;
                    
                case 'Backspace':
                    e.preventDefault();
                    if (currentInput.length > 0) {
                        currentInput = currentInput.slice(0, -1);
                        updateInputDisplay();
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (commandHistory.length > 0 && historyIndex > 0) {
                        historyIndex--;
                        currentInput = commandHistory[historyIndex];
                        updateInputDisplay();
                    }
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        currentInput = commandHistory[historyIndex];
                        updateInputDisplay();
                    } else if (historyIndex === commandHistory.length - 1) {
                        historyIndex = commandHistory.length;
                        currentInput = '';
                        updateInputDisplay();
                    }
                    break;

                case 'Tab':
                    e.preventDefault();
                    const tabCommands = ['help', 'whoami', 'contact', 'projects', 'skills',
                                         'llm', 'agents', 'date', 'asteroids', 'clear', 'auto'];
                    const partial = currentInput.toLowerCase().trim();
                    if (partial.length > 0) {
                        const matches = tabCommands.filter(cmd => cmd.startsWith(partial));
                        if (matches.length === 1) {
                            currentInput = matches[0];
                            updateInputDisplay();
                        }
                    }
                    break;

                default:
                    // Handle regular character input
                    if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                        e.preventDefault();
                        currentInput += e.key;
                        updateInputDisplay();
                    }
                    break;
            }
        });

        // Mobile support - tap to activate
        terminal.addEventListener('click', function() {
            if (!interactiveMode && autoMode) {
                switchToInteractive();
            }
        });

        // Prevent default touch behaviors that might interfere
        terminal.addEventListener('touchstart', function(e) {
            if (!interactiveMode && autoMode) {
                e.preventDefault();
                switchToInteractive();
            }
        });

        // Start the terminal simulation
        setTimeout(async () => {
            if (showBanner) {
                await showSecurityBanner();
            }
            showCommand();
        }, 1000);

        // Clean up terminal periodically
        setInterval(limitTerminalHistory, 5000);

        // Pause when tab is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Could pause animations here if needed
            }
        });
    </script>
    <script data-goatcounter="https://neuralconfig.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
</body>
</html>